[
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/",
        "title": "Jenkins",
        "tags": [],
        "description": "Jenkins 的使用、配置以及插件开发",
        "content": "Jenkins 的使用、配置以及插件开发\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/",
        "title": "DevOps",
        "tags": [],
        "description": "",
        "content": "DevOps 改变了我们软件生命周期迭代的思维和方法，不管是个人还是企业都可以从中获益。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/",
        "title": "编程语言",
        "tags": [],
        "description": "",
        "content": "编程语言就是我们的普通话，那就努力讲好普通话。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/",
        "title": "操作系统",
        "tags": [],
        "description": "",
        "content": "不了解操作系统还怎么开发、测试、运维？\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/",
        "title": "其他内容",
        "tags": [],
        "description": "",
        "content": "没有归类的部分\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/docker/",
        "title": "容器技术",
        "tags": [],
        "description": "容器技术",
        "content": "容器技术\n"
    },
    {
        "uri": "https://linuxsuren.github.io/speach/",
        "title": "Speaches",
        "tags": [],
        "description": "",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/",
        "title": "开源的技术网站",
        "tags": [],
        "description": "",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/speach/2022-08-open-source-world/",
        "title": "让我们一起了解开源",
        "tags": [],
        "description": "致广大开源用户",
        "content": "class: center, middle\n让我们一起了解开源 .black[@LinuxSuRen]\nname: catalog class: center, middle\n大纲 .black[个人职业发展] \u0026ndash; count: false\n.black[企业与开源] \u0026ndash; count: false\n.black[开源是什么] \u0026ndash; count: false\n.black[开源在哪里] \u0026ndash; count: false\n.black[如何迈出第一步] \u0026ndash; count: false\n.black[深入了解] name: career class: left, middle .left-column[\n职业发展 困境 ]\n.right-column.panding[\n得不到充足的锻炼、成长 复杂的、高难度的任务始终交由经验丰富的人做 技术止于商业诉求 业务线生命周期短 可用优先，质量、性能按需分配 技术选型保守，迭代缓慢 基于职位的决策机制，缺少创新 谁拍板，谁负责，谁受益 人脉圈小，社交范围局限 以同学、（前）同事为主要社交圈 ] .footnote.left.black[目录] class: left, middle、 .left-column[\n职业发展 .gray[困境] 突破 ]\n.right-column.panding[\n跳出舒适区 有机会精益求精 持久深耕特定领域 结识不同领域的有志之士 ] name: company-open-source .center[\n企业与开源 ]\n.left-column-eq.panding[ .right[产品免费，损失营收] .right[源代码无法作为核心资产] .right[内部团队之间难以复用] .right[大量修改开源代码，没有回馈上游，需要自行维护] .right.red[潜在的合规风险] ]\n.right-column-eq.panding[ .left[节省大量的产品宣传资源] .left[通用、基础性功能免费，企业级需求付费] .left[业务紧密相关的代码才是核心资产] .left[企业修改的开源代码交由全球开发者维护] .left[提升领域、行业内的技术品牌影响力] ]\n.footnote.left.black[目录]\n.left-column-eq[\n企业合规 潜在风险 ]\n.right-column-eq.vertical-center[ .center[引用了 GPL 等商业不友好的开源项目] .center[没有按规定指明依赖的开源项目] ]\n.footnote.left.black[目录]\n.left-column-eq[\n企业合规 .gray[潜在风险] 应对策略 ]\n.right-column-eq.vertical-center[ .center[普及合规常识] .center[建立开源项目清单] .center[聘请（全职、兼职）开源法律顾问] ]\n.footnote.left.black[目录]\n.left-column-eq[\n企业合规 .gray[潜在风险] .gray[应对策略] 案例 ]\n2021年9月29日，广州知识产权法院就罗盒网络科技有限公司诉玩友网络科技有限公司等侵害开源软件著作权纠纷一案作出一审判决，判决侵权行为成立，被告须立即停止通过互联网平台提供含有被侵权开源代码的相关软件，并赔偿原告经济损失及维权合理开支共计50万元。 https://www.zhichanli.com/p/158105840 \u0026ndash;\nTODO \u0026ndash;\nTODO \u0026ndash;\nTODO .footnote.left.black[目录]\n企业参与开源 .left-column-eq[\n默许 ]\n.right-column-eq.panding[ .left[对开源的认知停留在免费、公开的层面] .left[能解决自身业务问题即可] .left[项目类、定制类工程居多] .left[技术氛围淡薄] .left[初、中级程序员比重较大] ]\n企业参与开源 .left-column-eq[\n.gray[默许] 鼓励 ]\n.footnote.left.black[通用的贡献指南 https://linuxsuren.github.io/open-source-best-practice/how-to-contribute.md/]\n.left[核心产品深度依赖一些开源项目] .center[==========] .left[骨干：带头了解开源文化、参与上游，起到表率、示范效果] .left[新人招聘：优先选择有开源经验的候选人] .center[==========] .left[不止步于解决问题本身，探索通用方案] .left[提倡改进工作效率，预留更多时间去解决业务底层问题] .left[提高代码质量要求：单元测试、静态检查、代码风格] .left[核心代码严格执行代码 review 流程] .left[提倡使用英文编写注释] .center[==========] .left[大型开源项目背后往往会有个社区] .left[要熟悉、接纳社区的制度、流程，入“乡”随俗] .left[通过社区会议、活动、issue 等与社区成员互动、交流] .left[熟悉、遵循开源协作流程]\n企业参与开源 .left-column-eq[\n.gray[默许] .gray[鼓励] 上游优先 ]\n对所依赖的开源项目有深度依赖，有能力修复缺陷、功能改进\n\u0026ndash; 对项目架构、设计提出了更高要求，可以相对容易地在 fork 和 upstream 版本之间切换\n\u0026ndash; 抽象到 upstream 的核心价值在于降本增效\n企业参与开源 .left-column-eq[\n.gray[默许] .gray[鼓励] .gray[上游优先] 误区 ]\n无差别地激励、鼓励员工参与开源，不必要地浪费资源 公司层面缺少开源战略指导，政策摇摆不定、难以形成规模效应 简单化地理解、认识开源，以为只要把任务下发到研发即可 只要把代码放到 GitHub 上，就会有很多开发者来参与 开源协议只是君子协议，没有法律效益\n企业发起开源 .left-column-eq[\n常见形态 ]\n.center[大厂成熟解决方案开源，打造技术品牌效应] .center[大厂为避免其发起的技术轻易被淘汰而以开源的方式创建生态] .center[大厂竞争] .center[大厂内部出于职位晋升而开源的 KPI 项目] .center[特定技术领域，缺乏开源项目，抢占市场] .center[开源创业公司，以开源作为主要的商业模式] .center[小规模零星开源（试水、偶然）]\n企业发起开源 .left-column-eq[\n.gray[常见形态] 商业模式 ]\nOpen Core：社区版免费、企业版收费\nSaaS：项目免费，提供云服务\n双许可证（例如：MySQL）\n建立生态，设立插件、应用市场准入\n企业发起开源 .left-column-eq[\n.gray[常见形态] .gray[商业模式] 案例 ]\nTODO\nname: what-is-open-source\n开源是什么 .center[\nJust for fun 开放源代码软件 新兴的产品获客形式 极具潜力的商业模式 开放式协作 ]\n.footnote.left.black[目录]\nname: osd\nThe Open Source Definition .left-column-eq.panding[\nFree Redistribution Source Code Derived Works Integrity of The Author\u0026rsquo;s Source Code No Discrimination Against Persons or Groups No Discrimination Against Fields of Endeavor Distribution of License License Must Not Be Specific to a Product License Must Not Restrict Other Software License Must Be Technology-Neutral ] .right-column-eq[ ]\nclass: center\n我认为的开“源” \u0026ndash;\n以平等、公开、透明为基础的异步的协作方式 \u0026ndash;\n过程 \u0026gt; 结果 \u0026ndash;\n源，是源头活水的源 \u0026ndash;\n倡导互相成就，而不是控制 name: where-is-open-source background-image: url(FishDiagram.png)\n开源在哪里 .footnote.left.black[目录]\nname: first-step-open-source\n如何迈出开源第一步 找一个理由，让自己至少能坚持一年 设定一个具有一定挑战性的目标 体验、融入是重点，抛弃功利的考虑 .footnote.left.black[目录]\nclass: center, middle\n具体有哪些方向呢？ \u0026ndash;\n从做好一名用户开始 \u0026ndash;\n本地化文档 \u0026ndash;\ngood-first-issue \u0026ndash;\n参与社区活动 \u0026ndash;\n了解开源文化 .footnote.left.black[目录]\n.left-column[\n深入了解 文章 ]\n.center[\n夜天之书 卫sir说 ]\n.left-column[\n深入了解 .gray[文章] 视频 ]\n.center[\nKoala聊开源 OpenTEKr 开源之夏 ]\n.footnote.left.black[目录] name: godeep .left-column[\n深入了解 .gray[文章] .gray[视频] 播客 ]\n.center[\nALC Beijing Podcast OpenTEKr 大话开源 开源社·陪你看开源 开源雨林—大咖访谈 开源之道Talking 开源面对面 ]\n.footnote.left.black[目录] class: center, middle\n欢迎走进开源的世界 "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/basic/",
        "title": "Jenkins Basic",
        "tags": [],
        "description": "Jenkins Basic",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/basic/pipeline-slide/",
        "title": "流水线众生相之 Jenkins 对话 Tekton",
        "tags": [],
        "description": "分别介绍 Jenkins 和 Tekton 的流水线特性",
        "content": "class: center, middle, inverse\n流水线众生相之 Jenkins 对话 Tekton\nclass: inverse\nAbout Me .left-column-eq[\nCDF Ambassador GSoC mentor Jenkins Press Contact in China Jenkins Chinese Localization ] .right-column-eq[\nJenkins CLI Jenkins Chinese Simplified Plugin Jenkins Distribution Formulas Wechat backend ] class: inverse\n流水线 vs 手工 .left-column-eq[\n易执行，可复用 代码 可视化 统计信息 review ] .right-column-eq[\n繁琐，易出错 文档 + 脚本 依赖个人 ] class: inverse\n相关产品 .left-column-eq[ .img-max-width-200[ ] .img-max-width-200[ ] .img-max-width-200[ ] ]\n.right-column-eq[ .img-max-width-200[ ] .img-max-width-200[ ] .img-max-width-200[ ] ]\nclass: inverse\nJenkins vs Tekton .left-column-eq[\n传统部署、容器部署 非常成熟、丰富的插件 UI、CLI 功能完整 Jenkinsfile、groovy 动态构建节点 单点故障 本地文件系统存储 ] .right-column-eq[\nKubernetes v1beta1 CRD、yaml UI Dashboard Task、Pipeline 使用灵活 ] class: center, middle\nJenkins Jenkins automation server\nclass: inverse\nJenkinsfile pipeline { agent none stages { stage(\u0026#39;Example Build\u0026#39;) { steps { echo \u0026#39;Hello World\u0026#39; } } stage(\u0026#39;Example Deploy\u0026#39;) { when { beforeOptions true branch \u0026#39;testing\u0026#39; } options { lock label: \u0026#39;testing-deploy-envs\u0026#39;, quantity: 1, variable: \u0026#39;deployEnv\u0026#39; } steps { echo \u0026#34;Deploying to ${deployEnv}\u0026#34; } } } } class: inverse\n专业的组件做专业的事情 凭据 -\u0026gt; k8s 备份恢复 系统配置 -\u0026gt; git 配置修改的审核 数据文件 -\u0026gt; 共享存储 用户认证 -\u0026gt; oidc(ladp) class: inverse\nJenkins 节点标签 与节点连接类型结偶 每个节点可以有多个标签 名称命名要有业务意义 linux、java、mem-high 逻辑关系 linux \u0026amp; java 有哪些标签可以用？ class: inverse\nJenkins 节点管理 当好 master 推荐使用动态节点 一定要有 limit k8s 节点的限制 k8s 节点的伸缩 class: inverse\n构建优化 避免串行构建 内存、CPU 资源合理分配 Docker registry mirror Maven mirror HTTP proxy 构建状态监控 class: center, middle\nTekton A K8s-native Pipeline resource.\nclass: inverse\nTekton .left-column-eq[\nTask apiVersion: tekton.dev/v1beta1 kind: Task metadata: name: echo-hello-world spec: steps: - name: echo image: ubuntu command: - echo args: - \u0026#34;Hello World\u0026#34; ]\n.right-column-eq[\nTask Run apiVersion: tekton.dev/v1beta1 kind: TaskRun metadata: name: echo-hello-world-task-run spec: taskRef: name: echo-hello-world ]\nclass: inverse\nTekton Pipeline .left-column-eq[\napiVersion: tekton.dev/v1beta1 kind: Pipeline metadata: name: tutorial-pipeline spec: resources: - name: source-repo type: git - name: web-image type: image tasks: - name: build-skaffold-web taskRef: name: build-docker-image-from-git-source params: - name: pathToDockerFile value: Dockerfile - name: pathToContext value: /workspace/docker-source/examples/microservices/leeroy-web #configure: may change according to your source resources: inputs: - name: docker-source resource: source-repo outputs: - name: builtImage resource: web-image ]\n.right-column-eq[\napiVersion: tekton.dev/v1beta1 kind: PipelineRun metadata: name: tutorial-pipeline-run-1 spec: serviceAccountName: tutorial-service pipelineRef: name: tutorial-pipeline resources: - name: source-repo resourceRef: name: skaffold-git - name: web-image resourceRef: name: skaffold-image-leeroy-web ]\nclass: inverse\nTekton Resources apiVersion: tekton.dev/v1alpha1 kind: PipelineResource metadata: name: skaffold-image-leeroy-web spec: type: image params: - name: url value: gcr.io/\u0026lt;use your project\u0026gt;/leeroy-web class: inverse\nInstallation Pipeline Dashboard Trigger CLI kubectl apply --filename https://storage.googleapis.com/tekton-releases/pipeline/latest/release.yaml kubectl apply --filename https://github.com/tektoncd/dashboard/releases/download/v0.6.1.4/tekton-dashboard-release.yaml kubectl apply --filename https://storage.googleapis.com/tekton-releases/pipeline/latest/release.yaml brew tap tektoncd/tools brew install tektoncd/tools/tektoncd-cli class: center, middle\nThanks .img-max-height-200[ ]\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/",
        "title": "原创文章",
        "tags": [],
        "description": "原创文章",
        "content": "原创文章\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/docker/docker-build-tools-landscape/",
        "title": "Docker image build tools landscape",
        "tags": [],
        "description": "Docker image build tools landscape",
        "content": "There\u0026rsquo;re many tools could help us to build docker image.\nName Description makisu Fast and flexible Docker image building tool, works in unprivileged containerized environments like Mesos and Kubernetes. kaniko Build Container Images In Kubernetes ko Build and deploy Go applications on Kubernetes s2i A tool for building artifacts from source and injecting into container images makisu Fast and flexible Docker image building tool, works in unprivileged containerized environments like Mesos and Kubernetes. "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/plugin-dev/",
        "title": "Jenkins 插件开发",
        "tags": [],
        "description": "Jenkins 插件开发",
        "content": "Jenkins 插件开发\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/basic/jenkins-debug/",
        "title": "Jenkins 调试",
        "tags": [],
        "description": "Jenkins 调试",
        "content": "mvn jenkins-dev:run\nmvn jenkins-dev:run -Djenkins.install.runSetupWizard=true -DJENKINS_HOME=. 需要在目录 war 下运行，并保证没有 work 目录\njava -server -Xms200m -Xmx512m -jar jenkins.war --webroot=/var/cache/jenkins --httpPort=8090 -DJENKINS_HOME=./jenkins-home/ 设置 Jenkins 启动参数\nmvn clean install -DskipTests -Dfindbugs.skip=true -Dpmd.skip=true -Dmaven.javadoc.skip=true\nDocker 如果需要调试运行在 Docker 中的 Jenkins 实例的话，可以通过增加 JVM 参数来实现。对 Jenkins 启动过程感兴趣的同学，可以自行翻阅jenkins.sh来了解更多细节。\n添加如下环境变量\nJAVA_OPTS=-Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=5005,suspend=y\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/plugin-dev/jenkins-plugin-listener/",
        "title": "Jenkins 事件监听",
        "tags": [],
        "description": "Jenkins 事件监听",
        "content": " 类型 接口 描述 监听队列事件 hudson.model.queue.QueueListener 任务监听器 hudson.model.listeners.ItemListener 接收 Item 的 CRUD 操作事件 任务执行状态 hudson.model.listeners.RunListener 接收任务构建的事件 "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/basic/system_var/",
        "title": "Jenkins 系统属性配置",
        "tags": [],
        "description": "Jenkins 系统属性配置",
        "content": "Jenkins 有很多不包含在 UI 中的配置，可以应对一些特殊情况：\nKey Values hudson.model.DownloadService.noSignatureCheck true hudson.model.DirectoryBrowserSupport.CSP hudson.security.csrf.DefaultCrumbIssuer.EXCLUDE_SESSION_ID true kubernetes.websocket.ping.interval 10000 org.jenkinsci.plugins.gitclient.Git.timeOut 60 -Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION true "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/jenkins-plugin/",
        "title": "Jenkins Plugins",
        "tags": [],
        "description": "Jenkins 插件推荐以及介绍",
        "content": "Jenkins 有非常丰富的插件，这里是我整理出来的一些插件使用说明。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/jenkins-plugin/multi-branch-pipeline/",
        "title": "多分支流水线",
        "tags": [],
        "description": "多分支流水线",
        "content": "背景 通常的 Git 分支策略中，会有固定分支和临时分支。对于固定的，我们可以给每个分支都创建一条流水线。 但对于临时分支，有些团队的做法，会把分支作为参数。\n但实际上，单个代码仓库完全可以使用同一个流水线，也就是多分支流水线\n特点 支持基于一定的策略，扫描分支、PR、标签（tag），对符合过滤条件的会动态创建流水线。 当分支等被删除后，多分支流水线可以把之前创建出来的流水线删除。\n多分支流水线，本质上是存放流水线的容器（类似于文件夹）。\n分支扫描 默认支持的分支并发扫描可能是不够的，这时候，我们可以通过增加系统配置来修改：\n-Dcom.cloudbees.hudson.plugins.folder.computed.ThrottleComputationQueueTaskDispatcher.LIMIT=12\n要注意的是，插件会选择上面的限制值和当前系统的核心数中的较小值。\nWebhook 多分支流水线，可以自动添加 webhook 到 git 服务上，并基于 webhook 推送的事件负责分支流水线的生命流程管理。下面，是部分 git 服务中 所对应的 webhook 地址：\ngit 服务 地址 ContentType 限制 Bitbucket http://localhost:8080/jenkins/bitbucket-scmsource-hook/notify 每个仓库最多有50个 ｜ Gitlab http://localhost:8080/jenkins/gitlab-webhook/post application/json ｜ GitHub http://localhost:8080/jenkins/github-webhook/ application/json ｜ Jenkins 中的多分支流水线删除后，也会同时删除 Bitbucket 中的 webhook 记录，但是 GitHub 不会。\n缺点 对于 PR 的动态发现，目前只有 GitHub、Gitlab 和 Bitbucket 支持。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/bash/",
        "title": "Bash",
        "tags": [],
        "description": "Bash",
        "content": "字符串 替换 echo \u0026quot;ab/c/df\u0026quot; | sed 's/\\//-/g'\n参数 变量 说明 示例 $# 参数个数 $0 当前脚本文件名 $1 第一个参数，后面的参数则依次类推，例如：第二个参数为$2 $_ 上一条名称的最后一个参数 mkdir temp 命令自动补全 我们可以使用 brew 来安装 bash 的自动补全：brew install bash-completion\n目录 我们可以把特定命令的自动补全脚本保存到这个目录中 /usr/local/etc/bash_completion.d\n循环 for i in {1..5} do echo $i done "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/",
        "title": "Linux",
        "tags": [],
        "description": "Linux 操作系统",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/",
        "title": "Linux Common CLI",
        "tags": [],
        "description": "Linux Common CLI",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/build/maven/",
        "title": "Maven",
        "tags": [],
        "description": "Maven 是非常流行的一个 Java 持续构建工具",
        "content": " 构建 跳过JavaDoc mvn package -Dmaven.javadoc.skip=true\n跳过运行测试 mvn package -DskipTests=true 跳过测试代码的构建以及运行 mvn package -Dmaven.test.skip=true\nmvn package -U 强制更新快照版本的依赖\n离线 通常情况下，Maven 需要从网络上下载依赖文件，这样的话，执行效率会比较低。如果你确保本地仓库已经有了所有的依赖文件的话，可以添加参数使 Maven 不再从网络上下载，直接使用本地的依赖。例如：\nmvn clean package --offline\n部署 mvn deploy\n多模块 部署 如果有一个多模块的 Maven 工程，但是，在发布的时候有些工程不希望发布，例如：example 工程。这时候，可以在不需要发布的模块工程 pom.xml 中添加如下插件配置：\n\u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-deploy-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.8.2\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;skip\u0026gt;true\u0026lt;/skip\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; Alice-\u0026gt;Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob--\u0026gt;Alice: I am good thanks! 查看依赖 mvn dependency:tree 查看依赖树\nmvn dependency:resolve\nmvn dependency:analyze 依赖分析\nmvn help:effective-pom\n调试 mvn package -X 查看调试信息\n网络代理 \u0026lt;settings\u0026gt; \u0026lt;proxies\u0026gt; \u0026lt;proxy\u0026gt; \u0026lt;id\u0026gt;example-proxy\u0026lt;/id\u0026gt; \u0026lt;active\u0026gt;true\u0026lt;/active\u0026gt; \u0026lt;protocol\u0026gt;http\u0026lt;/protocol\u0026gt; \u0026lt;host\u0026gt;proxy.example.com\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8080\u0026lt;/port\u0026gt; \u0026lt;username\u0026gt;proxyuser\u0026lt;/username\u0026gt; \u0026lt;password\u0026gt;somepassword\u0026lt;/password\u0026gt; \u0026lt;nonProxyHosts\u0026gt;www.google.com|*.example.com\u0026lt;/nonProxyHosts\u0026gt; \u0026lt;/proxy\u0026gt; \u0026lt;/proxies\u0026gt; \u0026lt;/settings\u0026gt; 镜像 \u0026lt;mirrors\u0026gt; \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;nexus-aliyun\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Nexus aliyun\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://nexus-b.alauda.cn/repository/maven-public/\u0026lt;/url\u0026gt; \u0026lt;mirrorOf\u0026gt;*\u0026lt;/mirrorOf\u0026gt; \u0026lt;/mirror\u0026gt; \u0026lt;/mirrors\u0026gt; "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/build/",
        "title": "构建",
        "tags": [],
        "description": "程序构建",
        "content": "构建\n"
    },
    {
        "uri": "https://linuxsuren.github.io/translation/other/how-do-you-get-familiar-with-a-new-code-base/",
        "title": "你是如何熟悉一个新的项目的？",
        "tags": [],
        "description": "你是如何熟悉一个新的项目的？",
        "content": "我最近以软件工程师的身份在 DEV 上出现了。更换几次工作后，发现熟悉新的代码是快速适应一个新的角色过程的难题之一。\n当学习软件工程（学校、培训机构、在线教程等等）时，你通常是从头开始，或者项目还 处于早期设计阶段。例如：如果你刚学完 Rails 的教程，你可以利用有限的特性构建 一个博客。\n但是，\n因此，我的问题是：\n如何熟悉并运行一个全新的、 你会使用什么工具 "
    },
    {
        "uri": "https://linuxsuren.github.io/translation/other/",
        "title": "其他类型的翻译",
        "tags": [],
        "description": "其他类型的翻译",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/translation/other/abd/",
        "title": "什么是 API 网关",
        "tags": [],
        "description": "什么是 API 网关",
        "content": "什么是 API 网关？它是一个端口，控制东西的进入，例如：人、流量、请求。如果你已经对微服务有一些了解的话，那么应该已经了解了“API 网关”。\n不仅是在微服务中，API 网关自出现时就开始流行了。那么，到底什么是API 网关呢？\n基本概念 API 网关是鉴于客户端及其依赖的服务之间的一个中间层。\n传统模式 vs 前后端分离 API 网关的主要优势 API 网关的下游 API 网关和服务网格的关系 第三方 API 的来源 "
    },
    {
        "uri": "https://linuxsuren.github.io/translation/",
        "title": "文章翻译区域",
        "tags": [],
        "description": "文章翻译区域",
        "content": "文章翻译区域\n练习英文听力的网站：https://www.esl-lab.com/\n"
    },
    {
        "uri": "https://linuxsuren.github.io/translation/git/",
        "title": "Git 相关的翻译",
        "tags": [],
        "description": "Git 相关的翻译",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/translation/git/please-add-gitattributes-to-your-git-repository/",
        "title": "请把 .gitattributes 添加到你的 Git 仓库中",
        "tags": [],
        "description": "Git attributes",
        "content": "什么是 .gitattributes ？ 当执行 git 动作时，.gitattributes 文件允许你指定由 git 使用的文件和路径的属性，例如：git commit 等。\n换句话说，每当有文件保存或者创建时，git 会根据指定的属性来自动地保存。\n其中的一个属性是 eol(end of line)，用于配置文件的结尾。本文将会深入了解如何配置文件的结尾行，这样的话，即使在不同的机器、操作系统 上都可以使得每个开发者都可以使用相同的值。\n为什么是 .gitattributes（开发者之间的争议 ⚔️ ）? 不是所有的开发者都是一样的，不能因为你是在 Windows 上使用 Visual Studio Code 开发的，就期望别的 Pull Request 也是基于相同的开发 环境完成的（在 MacOS 上可能用的是 Sublime Text2）。\n正如上面提到的，开发者使用不同的操作系统，默认的文件结尾行就会不同。在 Windows 上默认的是回车换行（Carriage Return Line Feed, CRLF），然而，在 Linux/MacOS 上则是换行（Line Feed, LF）。\n从表面看起来，内容都是一样的，那我们为什么还会困扰呢？??\n好的，如果你启用了该功能，并设置属性 endOfLine 为 lf 的话。\n{ \u0026#34;endOfLine\u0026#34;: \u0026#34;lf\u0026#34; } 在 Windows 上，开发者会看到如下的检查警告。\n这时候 .gitattributes 就可以派上用场了 🦸！\n新仓库 首先，在仓库的根目录下创建名为 .gitattributes 的文件。\n下面，是一份 .gitattributes 文件的样例内容。\n*.js eol=lf *.jsx eol=lf *.json eol=lf 把该文件提交并推送到服务器上。\ngit add . git commit -m \u0026#34;Added .gitattributes to repo\u0026#34; git push 现在，任何人从仓库获取代码后，创建以及修改文件时，git 都会自动地设置好正确的文件结尾。\n增加到已有的 Git 仓库 正如上面提到的，在仓库的根目录下创建名为 .gitattributes 的文件。一旦文件推送到 git 服务器后，请确保你的本地 仓库是干净的、无需提交的。使用命令 git status 可以检查是否你的仓库是干净的。\n注意：如果你还有未提及或推送的文件，请确保这些动作已经被执行过了，或者在执行下面的命令前 stash 过。\n重置 GitAttributes git rm --cached -r git reset --hard 上面的命令就会根据文件 .gitattributes 中的定义，更新文件的结尾行。\n任何变更都会自动使用指定文件的文件结尾行格式。\n下一步，可以通知团队成员或者协作者去执行 Git 属性重置的命令。\n现在，prettier 就不会在提示有关 CR 的问题了，所有的开发者都可以安心写代码了! ☮️\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/plugin-dev/jenkins-plugin-debug/",
        "title": "Jenkins 插件调试",
        "tags": [],
        "description": "Jenkins 插件调试",
        "content": "运行 如果是在 Jenkins core 的源码目录下的话，需要进入到 war 目录；如果是插件的话，通常在根目录下执行：\nmvn hpi:run\n程序正常启动后，会在 target 下生成一个运行时的目录：target/jetty/webapp/\n跳过测试 mvn hpi:run -DskipTests 该命令会跳过测试的执行，但还是会编译测试代码的。如果确实想要加快构建速度而跳过测试的话，建议使用这个命令，而不是下面的：\nmvn hpi:run -Dmaven.test.skip=true 该命令既不执行测试代码，也不会编译。\n指定端口 `mvn hpi:run -Djetty.port=1234'\nmvn hpi:run -Djenkins.install.runSetupWizard=true\n指定 Jenkins 版本 mvn hpi:run -Djenkins.version=2.121.1\n参考 maven-hpi-plugin\n"
    },
    {
        "uri": "https://linuxsuren.github.io/speach/2019-08-19-jenkins-chinese-community/",
        "title": "Jenkins 社区在国内的发展",
        "tags": [],
        "description": "分享 Jenkins 中文社区作出的一些努力",
        "content": "class: center, middle\nJenkins 中文社区 .left[.footnote[Power by remark]]\nclass: center, middle\n开源 vs 闭源 工匠～利润\n开放～封闭\n共赢～竞争\n扁平～等级\n自由～局限\n多样～单一\n工匠～利润 .pull-left[\n通用性 安全性 代码质量 单元测试 迭代流程 便于协作 ] .pull-right[\n客户愿意为哪些功能买单 要在短时间内实现功能 来不及考虑代码质量、安全漏洞 ] 开放～封闭 .pull-left[ 公开地（所有人都可以参与到）进行需求讨论，公开地评审设计文档、代码、帮助文档，任何人都可以贡献——即使只是错别字 ]\n.pull-right[ 特定的团队负责特定的部分，例如：产品经理=》研发经理=》普通研发=》测试。通常情况下，下游的人员是不会参与到需求层面的，已经到了分析并整理完成后的任务了。 ]\n共赢～竞争 .pull-left[\n没有具体的职位，允许多人做同一件事情 竞争对手也可以合作 贡献值是公开的 ] .pull-right[\n同一岗位的人员需求，取决于人员配置以及预算 不同岗位的薪资不同 看不到在其他项目的贡献 ] 扁平～等级 .pull-left[\n没有一言堂 自由选择希望改善的任务 都是负责人 ] .pull-right[\n领导有非常大的决定权 通常是任务分配 ] 自由～局限 .pull-left[\n不会受工作背景的限制\n可以参与任何开源项目\n随时加入或退出\n.red[没有明确的任期] ]\n.pull-right[\n通常只能做本职的工作 受制于决策周期、方向 职位等级 优先完成任务，而不是质量 ] 多样～单一 .pull-left[\n在校大学生 研发 测试 运维 市场 其他 ] .pull-right[\n有特定工作背景 必须通过面试 ] .left-column[ Jenkins\n简体中文插件 ]\n.center[ ]\n.left-column[ 社区贡献者 ]\n.img-max-width-80[.center[ ]]\n.left-column[ 社区贡献者 ]\n.img-max-width-80[.center[ ]]\n.left-column[ 几点思考 ]\n协作的挑战 英语的重要性 原动力 商业vs免费 社区治理 class: center, middle\n持续交付黑客松 开源 开放 任何人、任何岗位都可以报名参加\n黑客 工匠精神 ~ 48小时\nclass: center, middle\n谢谢 共建、共赢、共享 .left[.footnote[Jenkins 中文社区]]\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/api/blueocean/",
        "title": "Blue Ocean",
        "tags": [],
        "description": "Blue Ocean",
        "content": "API 列表 获取 JUnit 测试包括的 API 包括如下：\nhttp://localhost:8080/jenkins/blue/rest/organizations/jenkins/pipelines/demo/runs/7/tests/?state=REGRESSION\u0026amp;start=0\u0026amp;limit=101\nhttp://localhost:8080/jenkins/blue/rest/organizations/jenkins/pipelines/demo/runs/7/tests/?status=FAILED\u0026amp;state!=REGRESSION\u0026amp;start=0\u0026amp;limit=101\nttps://localhost:8080/jenkins/blue/rest/organizations/jenkins/pipelines/demo/runs/7/tests/?status=SKIPPED\u0026amp;start=0\u0026amp;limit=101\nhttp://localhost:8080/jenkins/blue/rest/organizations/jenkins/pipelines/demo/runs/7/tests/?state=FIXED\u0026amp;start=0\u0026amp;limit=101\nhttp://localhost:8080/jenkins/blue/rest/organizations/jenkins/pipelines/demo/runs/7/tests/?status=PASSED\u0026amp;start=0\u0026amp;limit=101\n响应体的结构如下：\n{ Age int // Duration the time of test Duration float32 // ErrorDetails error details of test ErrorDetails string // ErrorStackTrace if the status is erro then error stack trace of test ErrorStackTrace string // HasStdLog indicate whether has standard log outpupt HasStdLog bool // ID id for the test report item ID string // Name is the name of test report item Name string State string // Status indicates the status of report item Status string } 在 Jenkins 的测试报告中，可以拿到五种状态： REGRESSION FAILED SKIPPED FIXED PASSED 其中 REGRESSION 和 FIXED 使用的字段为 state\nFAILED 状态则会和 REGRESSION 配合使用\nPASSED 和 SKIPPED 则使用的字段为 status\n上面的 API 返回的状态码可能会包括：400、404、200。当给出的状态值为非法时，例如：status=abc 就会返回 400。当该流水线中没有测试包括时会返回 404。错误时的响应体结构如下：\n{ \u0026#34;message\u0026#34; : \u0026#34;bad state PASSED\u0026#34;, \u0026#34;code\u0026#34; : 400, \u0026#34;errors\u0026#34; : [ ] } 测试报告概览 http://localhost:8080/blue/rest/organizations/jenkins/pipelines/folder/pipelines/pipelineName/runs/4/blueTestSummary/\n返回的 JSON 数据如下：\n{ \u0026#34;existingFailed\u0026#34;: 0, \u0026#34;failed\u0026#34;: 0, \u0026#34;fixed\u0026#34;: 0, \u0026#34;passed\u0026#34;: 2, \u0026#34;regressions\u0026#34;: 0, \u0026#34;skipped\u0026#34;: 0, \u0026#34;total\u0026#34;: 2 } 等待输入 curl -v -u \u0026#39;xxx:yyy\u0026#39; -H \u0026#39;Jenkins-Crumb: 40b3007303bfde11c3da475d8cae91b4\u0026#39; -H \u0026#39;Content-Type: application/json\u0026#39; -X POST http://localhost:8080/jenkins/blue/rest/organizations/jenkins/pipelines/p31/runs/22/nodes/9/steps/12/ -d \u0026#39;{ \u0026#34;id\u0026#34; : \u0026#34;23a650bfcb70a78700d7178183722292\u0026#34;, \u0026#34;parameters\u0026#34; : [{ \u0026#34;name\u0026#34; : \u0026#34;branch\u0026#34;, \u0026#34;value\u0026#34; : \u0026#34;master\u0026#34; }] }\u0026#39; 更多来自 Blue Ocean 的 Restful API 请参考 https://github.com/jenkinsci/blueocean-plugin/tree/master/blueocean-rest\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/api/",
        "title": "Jenkins API 介绍",
        "tags": [],
        "description": "Jenkins API 介绍",
        "content": "Jenkins API 介绍\n"
    },
    {
        "uri": "https://linuxsuren.github.io/categories/",
        "title": "Categories",
        "tags": [],
        "description": "",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/categories/cicd/",
        "title": "cicd",
        "tags": [],
        "description": "",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/categories/devops/",
        "title": "DevOps",
        "tags": [],
        "description": "",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/tags/docker/",
        "title": "Docker",
        "tags": [],
        "description": "",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/tags/helm/",
        "title": "Helm",
        "tags": [],
        "description": "",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/tags/jenkins/",
        "title": "Jenkins",
        "tags": [],
        "description": "",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/basic/jenkins/",
        "title": "Jenkins",
        "tags": ["Docker", "Helm", "Kubernetes", "Jenkins"],
        "description": "Jenkins 是一个开源的 CI/CD 平台，本文是对其进行简单的介绍",
        "content": "本文介绍 Jenkins 相关的内容，包括：如何启动、配置等等。\n部署 Jenkins 支持几种安装（启动）方式：\nWar 由于 Jenkins 是用 Java 语言来开发的，自然就会有 War 的打包方式。你需要首先在下载页面，选择一个版本。\n然后，执行命令 java -jar jenkins.war 启动后，就可以通过浏览器访问 http://localhost:8080/jenkins\n这种方式，方便简单，但是需要有 Java 环境。\nDocker 用容器的方式来运行 Jenkins 也很方便。只要执行命令 docker run -p 8080:8080 jenkins/jenkins:lts 即可。\n需要每周更新版的话，直接加上版本号即可 docker run -p 12345:8080 jenkins/jenkins:2.175\n挂载卷 docker run -v /your/home:/var/jenkins_home jenkins/jenkins:lts\n如果遇到类似下面的错误，可以尝试设置运行的用户：docker run -u root -v /root/.jenkins:/var/jenkins_home jenkins/jenkins:lts\nCan not write to /var/jenkins_home/copy_reference_file.log. Wrong volume permissions? touch: cannot touch \u0026#39;/var/jenkins_home/copy_reference_file.log\u0026#39;: Permission denied Kubernetes Helm 执行命令 helm install stable/jenkins --name my-jenkins\n如果希望看到具体内容请查看这里。\nKubeApps 上也可以找到 Jenkins\n版本选择 从 Jenkins 官网的下载页面，看到有很多版本可以下载，但是，具体该怎么选择呢。我下面给出一些建议：\n生产环境：最近一年内的 LTS（长期支持版） 相对正式的环境：最新的 LTS 体验：最新的 Weekly 插件研发：尽可能选择较老的 LTS 参数 Jenkins 在启动过程中，大多数的参数是具有默认值的。但是，对于一些特定的场景下，我们需要设置对应的参数值。\n端口 java -jar jenkins.war --httpPort=1234 设置 Jenkins 的监听端口。这样 Jenkins 会监听 0.0.0.0 上的端口，也就是外部网络也可以访问。\nJENKINS_HOME 我们可以在启动 Jenkins 时指定家目录，默认值为用户目录下的 .jenkins。参数（-D 参数必须要在 -jar 之前）如下：\njava -DJENKINS_HOME=. -jar jenkins.war 或者 java -Duser.home=. -jar jenkins.war\nWeb 上下文 在 Docker 容器环境下，Jenkins 的默认上下文是 /，如果要修改为 /jenkins 的话，修改下面参数的值即可： JENKINS_OPTS=\u0026quot;--prefix=/jenkins\u0026quot;\n时区 如果以 Docker 容器的方式来启动 Jenkins 的话，它默认的是 UTC 时区。 我们可能就需要设置为我们所在的当地时区。\ndocker run -v /etc/localtime:/etc/localtime -p 8080:8080 jenkins/jenkins:lts\n向导 Jenkins 在首次运行时，会有一个配置向导，可以通过下面的参数跳过这个向导：\njava -Djenkins.install.runSetupWizard=false -jar jenkins.war\n用户 --argumentsRealm.passwd.admin=admin --argumentsRealm.roles.admin=admin\nHTTPS --httpsPort=8083 --httpsCertificate=/var/lib/jenkins/cert --httpsPrivateKey=/var/lib/jenkins/pk\n重启 如果，我们需要重新启动 Jenkins，没有必要把进程杀掉后再次启动。可以直接在 Jenkins 界面上就实现重启。\n访问地址 http://localhost:8080/restart 后点击确认。\n公钥 访问下面的地址可以得到 Jenkins 的公钥：\nhttp://localhost:8080/instance-identity/\n"
    },
    {
        "uri": "https://linuxsuren.github.io/tags/kubernetes/",
        "title": "Kubernetes",
        "tags": [],
        "description": "",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/tags/",
        "title": "Tags",
        "tags": [],
        "description": "",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/basic/jenkins-queue/",
        "title": "Jenkins 队列",
        "tags": [],
        "description": "队列在 Jenkins 中是非常重要的环节",
        "content": "我们知道，在 Jenkins 中执行任务的话，执行过程是：\n进入队列 查找是否有可以执行该任务的节点 启动节点执行任务 这里队列的默认行为是：先进先出。这对于很多常规场景下是正常合理的，毕竟首先触发的任务应该先执行。\n但是，在实际的企业（或组织）应用中，往往会有更加复杂的场景需求。例如：部分任务的优先级相对比较高、持久化队列等等。有一些需求，已经有相对应的插件可以实现，本文会对默写场景进行描述。\nhttps://github.com/jenkinsci/purge-build-queue-plugin https://github.com/jenkinsci/priority-sorter-plugin https://github.com/jenkinsci/persistent-build-queue-plugin https://github.com/jenkinsci/merge-queue-plugin\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/scm/github/",
        "title": "GitHub",
        "tags": [],
        "description": "GitHub",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/scm/github/hub/",
        "title": "Hub",
        "tags": [],
        "description": "hub 是让 git 可以更加方便地访问 GitHub 的命令行",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/scm/",
        "title": "SCM",
        "tags": [],
        "description": "SCM",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/scm/git/",
        "title": "Git",
        "tags": [],
        "description": "Git",
        "content": "Git 是一个免费、开源的分布式的版本控制系统。\n而对于 GitHub 的用户，可以使用 hub 作为你日常使用的命令行工具。它把 git 与 GitHub 的功能无缝地对接 在一起。例如：hub 命令可以很方便地查看当前仓库中的 PR 列表，快速地检出某个 PR.\nGit 支持我们把代码推送到单个或者多个远程库中。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/scm/git/git-log/",
        "title": "Git Log",
        "tags": [],
        "description": "使用 git 查看日志相关的内容",
        "content": "返回最新的一次提交记录 git log -1\n查看某个文件的提交记录 git log somefile\n查看某个文件的变更内容 git log -p Jenkinsfile\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/team/jira/",
        "title": "Jira",
        "tags": [],
        "description": "Jira",
        "content": "docker pull cptactionhank/atlassian-jira-software:latest\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/team/",
        "title": "Team",
        "tags": [],
        "description": "Team",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/docker/elastic-search/",
        "title": "Elastic Search",
        "tags": [],
        "description": "Elastic Search",
        "content": "docker run -p 9200:9200 -p 9300:9300 -e \u0026quot;discovery.type=single-node\u0026quot; docker.elastic.co/elasticsearch/elasticsearch:5\n可视化 docker run -p 9100:9100 mobz/elasticsearch-head:5\nkibana\ndocker run -p 5601:5601 docker.elastic.co/kibana/kibana:5.6.16\ndocker run -e \u0026ldquo;XPACK_GRAPH_ENABLED=false\u0026rdquo; \u0026ndash;link goofy_curie:elasticsearch -e \u0026ldquo;ELASTICSEARCH_URL=http://localhost:9200\u0026rdquo; -p 5601:5601 docker.elastic.co/kibana/kibana:5.6.16\ndocker run \u0026ndash;name kibana \u0026ndash;link goofy_curie:elasticsearch -e \u0026ldquo;ELASTICSEARCH_URL=http://10.222.0.1:9200\u0026rdquo; \u0026ndash;net default -p 5601:5601 kibana:5\ndocker run -p 5601:5601 -p 9200:9200 -p 5044:5044 sebp/elk:es241_l240_k461\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/api/token/",
        "title": "Token",
        "tags": [],
        "description": "Token",
        "content": "curl http://localhost:8080/user/admin/descriptorByName/jenkins.security.ApiTokenProperty/generateNewToken --header \u0026#34;Authorization: Basic `echo -n admin:1182fc5ef9b28a630986cb50c0319eb9d0 | base64`\u0026#34; -X POST -d \u0026#39;newTokenName=name\u0026#39; 返回的数据如下所示：\n{\u0026#34;status\u0026#34;:\u0026#34;ok\u0026#34;,\u0026#34;data\u0026#34;:{\u0026#34;tokenName\u0026#34;:\u0026#34;test\u0026#34;,\u0026#34;tokenUuid\u0026#34;:\u0026#34;3a07e7d7-c864-4474-bc3c-d217938e460e\u0026#34;,\u0026#34;tokenValue\u0026#34;:\u0026#34;1123acbf5d3e93e628a38dc0a671cf0194\u0026#34;}} "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/recommendation/work/",
        "title": "Work",
        "tags": [],
        "description": "Work",
        "content": "http://219.232.200.39/uamsso/\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/recommendation/",
        "title": "推荐信息",
        "tags": [],
        "description": "",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/tar/",
        "title": "Tar",
        "tags": [],
        "description": "Tar",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/api/pipeline/",
        "title": "Pipeline",
        "tags": [],
        "description": "Pipeline",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/sort/",
        "title": "Sort",
        "tags": [],
        "description": "Sort",
        "content": "文件列表排序 使用降序对当前目录中的文件（夹）进行排序 ls | sort -r\n版本号 我们可以借助 sort 命令对版本号进行排序，只需要使用参数 -V 即可，下面的参数 -r 是降序的意思\necho \u0026#34;2.0 10.0 3.0\u0026#34; | sort -Vr 从下面的例子中可以看到，sort 命令对带字符前缀的情况也同样是支持的：\necho \u0026#34;v2.0 v10.0 v3.0\u0026#34; | sort -V "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/recommendation/english-abbreviations/",
        "title": "English Abbreviations",
        "tags": [],
        "description": "English Abbreviations You Should Know",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/recommendation/learning-english/",
        "title": "学习英语",
        "tags": [],
        "description": "介绍一些学习英语的技巧与资源",
        "content": "有很多学习英语的资料，可能会用到“梯子”，读者可以根据自身的情况进行选择。\n网站 名称 梯子 备注 EngVid yes 有初中高不同等级的视频 视频 名称 梯子 备注 和 Emma 学英语 yes How to Talk Like a Native Speaker yes 字典 学习英语的过程中，经常会遇到很多生词，这时候就需要使用到字典了。下面推荐几个我在学习中用到的一些：\n名称 梯子 备注 BusinessDictionary no 商业相关的词汇 FreeDictionary no 丰富的词条、习语等 Google no 支持很多种语言 词汇 pharmaceutical condition engineer spare time\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/plugin-dev/jenkins-i18n/",
        "title": "Jenkins I18n",
        "tags": [],
        "description": "Jenkins I18n",
        "content": "帮助文件 hudson.model.Descriptor\n与当前页面（jelly）在同一个目录下 存放在 webapp/help 目录下 http://localhost:8080/jenkins/descriptor/hudson.ProxyConfiguration/help/port\nhttp://localhost:8080/jenkins/help/parameter/file.html\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/zip/",
        "title": "Zip",
        "tags": [],
        "description": "Zip",
        "content": "删除文件 我们可以在不解压的前提下直接把压缩包中的文件删除 zip --delete demo.jar \u0026quot;**/*_zh_CN*\u0026quot;\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/shell-troubleshooting/",
        "title": "Shell Troubleshooting",
        "tags": [],
        "description": "Shell Troubleshooting",
        "content": "line 33: syntax error: unexpected end of file 通常情况下面，遇到这个问题，可能是由于换换行符导致的，我们可以通过执行下面的命令来解决：\ndos2unix yourfile.sh\n但是，如发现报错的行数根本不存在（没有那么多）的话，就可能是由于一些语法错误导致的。\n例如：if 对应的结束符是 fi，如果没有用对，就会报错。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/unzip/",
        "title": "Unzip",
        "tags": [],
        "description": "Unzip",
        "content": "解压 unzip git.zip\n列出压缩包中的文件 unzip -l git.zip\n输入压缩包中的文件内容 我们可以把 zip 压缩包中的文件内容解压后读取，但也可以做到直接读取而无需解压 unzip -c git.zip META-INF/MANIFEST.MF\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/basic/jenkins-backup/",
        "title": "Jenkins Backup",
        "tags": [],
        "description": "Jenkins Backup",
        "content": "本文是把 Jenkins 2.164.2 的数据备份到了 2.175 上。\n插件 首先，我们需要进入到 Jenkins 配置的根目录中（默认为：~/.jenkins）：\n备份\ntar czvf jenkins.plugins.tar.gz plugins/*.jpi cp jenkins.plugins.tar.gz ~ 凭据 我需要备份的环境运行在 Kubernetes 集群上，因此，下面是通过命令行 kubectl 把凭据相关的文件拷贝出来的， 读者可以结合自己的情况酌情调整：\nkubectl cp jenkins-599d58c694-sh46d:var/jenkins_home/secret.key ~/.jenkins -n default kubectl cp jenkins-599d58c694-sh46d:var/jenkins_home/credentials.xml ~/.jenkins -n default kubectl cp jenkins-599d58c694-sh46d:var/jenkins_home/secrets ~/.jenkins/secrets -n default Jenkins 默认会把所有的凭据信息保存到 credentials.xml 这个文件中。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/api/",
        "title": "API",
        "tags": [],
        "description": "API",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/api/open-api/",
        "title": "OpenAPI",
        "tags": [],
        "description": "OpenAPI",
        "content": "类型约束 F0416 03:23:25.690611 1 openapi.go:40] Failed to register open api spec for root: non-body Restful parameter type should be a simple type, but got : 遇到这个错误，可以把复杂对象的数组变成为一个指针对象，然后，在对象里添加数组。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/recommendation/video/",
        "title": "Video",
        "tags": [],
        "description": "Video",
        "content": "格式转换 这个网站可以把 Youtube 上的视频转换为 mp4 格式并提供下载链接。\nhttps://youtubemp4.to/\n下载 我们可以通过一个命令行工具来从 Youtube 上下载视频，首先，使用 brew 来安装命令行：\nbrew install youtube-dl\n然后，就可以开始下载了：\nyoutube-dl \u0026quot;https://www.youtube.com/watch?v=EtlhC3vw8pA\u0026quot; --proxy 127.0.0.1:1087\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/scm/github/github-robot/",
        "title": "GitHub Robot",
        "tags": [],
        "description": "GitHub Robot",
        "content": "这里列出一些 GitHub 中的“机器人”。\nStale Stale可以监控已有的 PR 列表，对于长期没有更新的 PR 会自动 添加“过期”的标签。当这类 PR 再次有更新或者评论时，自动取消“过期”标签；如果还是没有任何变化的话，会讲对应 的 PR 关闭。\n这样就能做到，提供贡献者及时查看自己相关的 PR 动态。\nutterances utterances 是基于 GitHub 的 Issues 来提供评论功能的服务。 对于使用 Hugo 这样的静态网页式的博客，可以非常方便地添加 网友评论功能——但无需任何数据库的服务。\nPR Robot PR Robot\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/jenkins-plugin/pipeline-input-step/",
        "title": "Pipeline Input Step",
        "tags": [],
        "description": "Pipeline Input Step",
        "content": " 该插件实现了一个在构建过程中 允许人工干预的功能，\n源代码托管在 Jenkins 的官方仓库中。\n它提供的 DSL 语句为 input，执行到该语句的时候，需要人工决定“通过”或者“拒绝”。它还支持设置允许点击”通过“的人或者组，以及 确认该操作时输入一些参数。\n示例 在下面的例子中，通过的话会打印用户输入的参数 name 的值；如果拒绝的话，当前流水线会直接失败\nscript { def approver = input id: \u0026#39;approveId\u0026#39;, message: \u0026#39;need your approve\u0026#39;, parameters: [string(defaultValue: \u0026#39;\u0026#39;, description: \u0026#39;Your name\u0026#39;, name: \u0026#39;name\u0026#39;, trim: false), string(defaultValue: \u0026#39;\u0026#39;, description: \u0026#39;Your age\u0026#39;, name: \u0026#39;age\u0026#39;, trim: false)] if (approver != null) { print approver.name } else { print \u0026#34;no data from approver\u0026#34; } } API 对于“通过”或者“拒绝“这样的操作，你可以使用 API 调用的方式来实现。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/api/approve/",
        "title": "Approve",
        "tags": [],
        "description": "Approve",
        "content": "这里介绍的是核准插件中的 API 使用。\n\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;admonition-content\u0026quot;\u0026gt; 该 DSL 是基于某一次构建的，因此，下面的 API 都需要对应的构建 ID。另外，还需要对应的 inputid。另外，下面提到的 API 并不是基于 Restful 风格 编写的，实际上是以表单的方式来提交的。也就是说，需要在发送请求时，在协议头中加入 Content-Type: application/x-www-form-urlencoded\n通过 input 这个 DSL 支持接收参数。\n无参数 对于没有参数的情况，可以使用下面的两个 API 来核准。\ncurl http://localhost:8080/job/pipeline/1/input/inputid/proceed \\ --header \u0026#34;Authorization: Basic `echo -n admin:token | base64`\u0026#34; -X POST 下面的 API 是直接无参数的调用\ncurl http://localhost:8080/job/pipeline/1/input/inputid/proceedEmpty \\ --header \u0026#34;Authorization: Basic `echo -n admin:token | base64`\u0026#34; -X POST 有参数 参数需要以 JSON 数组的形式传递。\ncurl http://localhost:8080/job/pipeline/1/input/inputid/proceed \\ --header \u0026#34;Authorization: Basic `echo -n admin:token | base64`\u0026#34; \\ -X POST -d \u0026#39;json={\u0026#34;parameter\u0026#34;: [{\u0026#34;name\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;bob\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;age\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;12\u0026#34;}]}\u0026#39; 如果缺少参数的话，会返回 400\n拒绝 拒绝执行，可以调用下面的 API\ncurl http://localhost:8080/job/pipeline/1/input/inputid/abort \\ --header \u0026#34;Authorization: Basic `echo -n admin:token | base64`\u0026#34; -X POST "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/jenkins-plugin/embeddable-build-status/",
        "title": "Embeddable Build Status",
        "tags": [],
        "description": "Embeddable Build Status",
        "content": "Embeddable Build Status 可以让你在其他的页面中显示的你的项目构建状态。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/recommendation/technical-website/",
        "title": "Technical Website",
        "tags": [],
        "description": "Technical Website",
        "content": " dev.to X-lab 开放实验室阅读俱乐部\nCode Cartoon\ncloud shell\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/jenkins-plugin/adopt/",
        "title": "孤儿插件",
        "tags": [],
        "description": "孤儿插件",
        "content": "Jenkins 有众多的插件，但由于各种原因，有些插件的作者不再维护。如果你对这一类插件感兴趣，希望能继续维护下去的话，可以去认领。\n需要被认领的插件.\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/basic/jenkins-initialization/",
        "title": "Jenkins Initialization",
        "tags": [],
        "description": "Jenkins Initialization",
        "content": "你可以创建一个 Groovy 脚本文件，例如 $JENKINS_HOME/init.groovy 或者目录 $JENKINS_HOME/init.groovy.d/ 下的任意脚本 .grooy. 它就会在 Jenkins 启动后执行。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/opensource/acronym/",
        "title": "Acronym",
        "tags": [],
        "description": "Acronym",
        "content": "PTAL please take a look\nLGTM look good to me\nhttps://www.smart-words.org/abbreviations/text.html\n"
    },
    {
        "uri": "https://linuxsuren.github.io/opensource/",
        "title": "我的开源项目",
        "tags": [],
        "description": "列出来我发起或者维护的一些开源项目",
        "content": "Jenkins jcli 是用 Go 语言编写的 Jenkins 命令行客户端，可以帮助 Jenkins 的 用户、管理员或者开发者简化日常的工作。\nhugo-plugin 是一个用于构建和发布基于 Hugo 静态网站的插件。\nlocalization-zh-cn-plugin 是 Jenkins 简体中文插件，包含了 Jenkins 核心以及部分插件的本地化。\njenkins-client-java 是 Jenkins 的 Java 客户端\n自动化测试 phoenix.webui.framework 是用 Java 编写的基于 Selenium 的自动化测试框架\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/plugin-dev/jenkins-plugin-dev-build/",
        "title": "扩展 Jenkins 的构建（Builder）任务",
        "tags": [],
        "description": "本文介绍如何扩展 Jenkins 的构建（Builder）任务。",
        "content": "构建 本文介绍如何扩展 Jenkins 的构建（Builder）任务。\n流水线 "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/scm/git/git-config/",
        "title": "Git Config",
        "tags": [],
        "description": "Git Config",
        "content": "修改作者 git commit --amend --author=\u0026quot;Author Name \u0026lt;name@email.com\u0026gt;\u0026quot;\n修改提交记录 git commit --amend 执行该命令后直接修改上次的提交记录即可\n本地/全局 通过参数可以指定是对全局还是当前项目的修改\ngit config --local user.email \u0026lt;name@email.com\u0026gt;\ngit config --global user.email \u0026lt;name@email.com\u0026gt;\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/k8s/helm/",
        "title": "helm",
        "tags": [],
        "description": "helm",
        "content": "helm repo list 列出所有已经配置的 chart 仓库\nhelm status jenkins 插件 chart 安装后的状态，和首次安装后打印出来的内容一致\nhelm get values jenkins 显示 chart 在安装时指定的自定义值\nhelm get values jenkins --revision 1 显示 chart 的历史安装自定义值\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/k8s/",
        "title": "Kubernetes",
        "tags": [],
        "description": "Kubernetes",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/k8s/tiller/",
        "title": "Tiller",
        "tags": [],
        "description": "Tiller",
        "content": "第一次使用 helm 时需要进行初始化（如果服务端没有对应的容器启动的话），初始化命令为 helm init\n当执行 helm list 时遇到了下面的报错信息\nError: configmaps is forbidden: User \u0026quot;system:serviceaccount:kube-system:default\u0026quot; cannot list configmaps in the namespace \u0026quot;kube-system\u0026quot;\n你可以通过添加集群管理员权限来修复这个问题：\nkubectl create clusterrolebinding add-on-cluster-admin --clusterrole=cluster-admin --serviceaccount=kube-system:default\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/golang/",
        "title": "Golang",
        "tags": [],
        "description": "Golang",
        "content": "Golang\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/golang/init/",
        "title": "Init",
        "tags": [],
        "description": "Init",
        "content": "init 函数定义在包（package）中，并有如下的用处：\n初始化变量（无法在初始化表达中完成的） 注册 执行一次性计算 包初始化 为了使用一个导入的包，首先需要初始化。这是由 Golang 的运行时系统完成，包含如下步骤：\n初始化导入的包（递归） 计算在包级别申明的变量并赋值 执行包中的 init 函数 \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;admonition-content\u0026quot;\u0026gt; 包初始化只会执行一次，即使会被导入多次。\n属性 init 函数没有任何参数，也不会返回任何值。而且，它也无法被调用。\ninit 函数可以定义多次。\n只在内部导入包 Go 对于没有用到的包是很严格的。有时候，我们可能希望导入一个包，只是为了调用 init 函数。可以按照如下方式来：\nimport _ \u0026quot;image/png\u0026quot;\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/scm/git/git-gc/",
        "title": "Git GC",
        "tags": [],
        "description": "清理无用的文件并优化本地仓库",
        "content": "在当前库中运行一些清理任务，例如：压缩文件版本（减少磁盘占用，提高性能），移除垃圾对象。\n鼓励用户在每个库中定期运行该任务，这样能保持更好的磁盘利用率，以及运行性能。\n一些 git 命令会自动执行 git gc。查看参数 --auto 了解更多细节。如果你希望永久禁用该功能并知道后果的话，可以执行如下命令：\ngit config --global gc.auto 0\n本地分支 查看已经合并过的分支\ngit branch --merged\n查看未合并过的分支\ngit branch --no-merged\n远程分支 清理远程过期的分支引用\ngit remote prune origin\n我们也可以在拉取远程分支信息的时候执行清理任务\ngit fetch -p\n查看已经合并过的远程分支\ngit branch -r --merged\n更多的分支操作\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/test/selenium/",
        "title": "Selenium",
        "tags": [],
        "description": "Selenium",
        "content": "远程模式 在 下载页面中，找到 Selenium Standalone Server 并下砸，然后执行如下的命令：\njava -jar selenium-server-standalone-{VERSION}.jar\n然后就可以访问 http://localhost:4444/wd/hub\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/test/",
        "title": "测试",
        "tags": [],
        "description": "",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/netcat/",
        "title": "Netcat",
        "tags": [],
        "description": "Netcat",
        "content": "nc -l 9090 启动一个监听指定端口的服务\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/api/crumissuer/",
        "title": "CrumIssuer",
        "tags": [],
        "description": "跨站请求伪造保护",
        "content": "如果配置了跨站请求伪造保护的话，可以通过下面的命令来获取相应的 Token\ncurl -u user:passwd http:/localhost:8080/jenkins/crumbIssuer/api/json\n返回值类似于，而如果没有启用该配置的话会返回 404\n{\u0026#34;_class\u0026#34;:\u0026#34;hudson.security.csrf.DefaultCrumbIssuer\u0026#34;,\u0026#34;crumb\u0026#34;:\u0026#34;6e78c5725ea0c522bdcb787d548465aa\u0026#34;,\u0026#34;crumbRequestField\u0026#34;:\u0026#34;Jenkins-Crumb\u0026#34;} 使用该 Crumb 的方式如下：\ncurl -u user:passwd http:/localhost:8080/jenkins/job/jobName/build -X POST --header \u0026quot;Jenkins-Crumb: 6e78c5725ea0c522bdcb787d548465aa\u0026quot;\n使用 Python 获取 Crumb 值：\nexport issuer=$(curl -u admin:$JENKINS_TOKEN $JENKINS_URL/crumbIssuer/api/json -s) issuer=$(python -c \u0026#34;import json;import os;issuer=os.getenv(\u0026#39;issuer\u0026#39;);issuer=json.loads(issuer);print issuer[\u0026#39;crumb\u0026#39;]\u0026#34;) "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/api/multi-branch/",
        "title": "多分支流水线",
        "tags": [],
        "description": "多分支流水线",
        "content": "扫描多分支 curl -X POST -u user:passwd http://localhost:8080/jenkins/job/jobName/build --header \u0026quot;Jenkins-Crumb: 6e78c5725ea0c522bdcb787d548465aa\u0026quot;\nJenkins-Crumb 需要单独获取。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/jenkins-plugin/github/",
        "title": "Github",
        "tags": [],
        "description": "Github",
        "content": "webhook 该插件提供的默认 webhook 地址为：http://localhost/github-webhook/。\n同时，也提供修改该地址的配置。\n我们需要在 GitHub 的 webhook 设置页面添加，Content type 要选择 application/json\n如果要支持多分支流水线的话，主要需要确保勾选事件：Pull Request\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/jenkins-plugin/dingding-notifications/",
        "title": "钉钉通知",
        "tags": [],
        "description": "钉钉通知",
        "content": "支持的特性包括：\n发送任务状态 发送文本类型的消息 安装插件 在 系统管理》插件管理》可选插件 中搜索 dingding-notifications 并安装。\n机器人 在钉钉中新建一个群，然后在群里添加一个机器人，选择自定义类型。\n自由风格 在 Jenkins 中新建自由风格任务\n在 构建后操作 中 添加钉钉通知器配置 。在表单中需要把 Jenkins 的 URL 设置正确——必须让钉钉可以访问到。Token 是刚才在钉钉机器人里的 webhook 里。\n上面的方式，只能发送构建状态，如果要发送自定义消息的话，需要添加 Sending Message To Ding Talk。在高级选项里可以设置。\n流水线 你也可以在流水线（Jenkinsfile）中使用下面是 DSL 来实现发送消息：\ndingTalk accessToken: 'token', imageUrl: 'imageUrl', jenkinsUrl: 'http://localhost/jenkins', message: 'messages', notifyPeople: '18211192837' "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/golang/ginkgo/",
        "title": "Ginkgo",
        "tags": [],
        "description": "Ginkgo",
        "content": " Ginkgo 是 Golang 的 BDD 测试框架。 从它的 官方文档 中可以看到大致的用法。可惜的是，写文本时还没有中文的文档。\n\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;admonition-content\u0026quot;\u0026gt; ️⚠️值得注意的是：测试用例的文件必须是以 test 结尾的，例如：foo_test.go\nGomega 是 Ginkgo 推荐的逻辑判断库，查看 官方文档，了解更多内容。\n执行测试 ginkgo test pkg/registry/generic\nIDE 插件 VS-Code 的插件 vscode-ginkgo\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/golang/gmock/",
        "title": "GoMock",
        "tags": [],
        "description": "GoMock",
        "content": " GoMock 是 Go 语言的 Mock 框架。它可以很很好地和 Go 内置的 testing 包集成。\n安装 你只要安装了 Go 就可以通过下面的命令来安装 gomock 和 mockgen 工具。\ngo get github.com/golang/mock/gomock go install github.com/golang/mock/mockgen 编写接口（测试用） codes/golang/gmock/foo.go package main // Foo no-sense interface demo type Foo interface { Max(a, b int) int } func main() {} 原文件 生成 Mock 接口 执行命令 mockgen --source=foo.go --destination foo-mock.go\n测试用例 codes/golang/gmock/foo_test.go package main import ( \u0026#34;testing\u0026#34; \u0026#34;./mock_main\u0026#34; \u0026#34;github.com/golang/mock/gomock\u0026#34; ) func TestFoo(t *testing.T) { ctrl := gomock.NewController(t) defer ctrl.Finish() expect := 2 m := mock_main.NewMockFoo(ctrl) m.EXPECT().Max(1, 2).Return(expect) if m.Max(1, 2) != expect { t.Errorf(\u0026#34;max result is wrong, should be %d\\n\u0026#34;, expect) } } 原文件 "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/basic/course/",
        "title": "Jenkins 培训",
        "tags": [],
        "description": "Jenkins 培训大纲",
        "content": "class: center, middle\nJenkins 培训 大纲 Jenkins 项目介绍 安装、部署 传统环境 容器环境 插件管理 构建任务 流水线 多分支流水线 API 计算节点管理 静态 动态 大纲 日志、任务外部存储 权限、认证体系 安全防护 备份、恢复 集成 社区介绍 Gitter \u0026amp;\u0026amp; 邮件组 Meetup 特别兴趣小组（SIG） 基础设施 安装、部署 Jenkins 的版本分为长期支持版（LTS）和每周更新版。\n安装手册 Docker 插件管理 介绍 仓库 托管 计算节点管理 节点类型 固定 动态（虚拟机、Docker、Kubernetes） 通道 SSH JNLP 标签（label） 表达式 流水线（Pipeline） Jenkins 流水线采用 Groovy 来编写，通常会保存在代码库根目录下名为 Jenkinsfile 的文件中。根据写法不同，分为：脚本式、申明式流水线。\n快速入手，参考：\n语法生成器 步骤列表 例子 复用 IDE 插件 .left[.footnote[https://linuxsuren.github.io/blog/devops/jenkins/pipeline/]]\n多分支流水线（Multi-branch Pipeline） 对于使用 Git 作为代码仓库的团队来说，Jenkins 的多分支流水线能够充分地利用 Git 的分支功能，简化重复的工作。简单来说，它可以根据既定的策略动态地创建、删除流水线。而对于部分 Git 服务，还能很好地支持 Pull Request 的流水线构建。\nAPI Jenkins 的大部分操作支持通过 HTTP API 进行调用，可以返回 JSON、XML 的数据格式。\nclass: center, middle\n社区介绍 Jenkins Community\n沟通交流 推荐的交流途径包括：Gitter、Google 邮件组。不同的主题，会有不同频道、组。\n普通用户（中文、英文） 开发者 特别兴趣小组 .left[.footnote[https://remarkjs.com]]\nMeetup 线上、线下交流活动。每年，在国内很多城市都组织一些线下交流活动。\n北京 西安 上海 深圳 分享的主题通常包括：特性介绍、案例分享、工作坊等。\n.left[.footnote[https://www.meetup.com/Beijing-Jenkins-Area-Meetup/]]\nclass: center, middle\n特别兴趣小组 Jenkins Special Interest Groups\n.left[.footnote[SIGs]]\n??? here is the note\n中文本地化 致力于改善 Jenkins 的中文用户的使用体验。涉及的范围包括： Jenkins 核心和插件以及官方网站。欢迎加入！\n官网（Jenkins、JX） Jenkins 及其插件 Jenkins 官方微信公众号 定期会议 .footnote[Chinese Localization]\n宣传与推广 平台 "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/api/core/",
        "title": "Jenkins 核心",
        "tags": [],
        "description": "Jenkins 核心的 API",
        "content": "你可以通过如下的方式来访问 Jenkins：\n单个任务 curl http://localhost:8080/jenkins/job/jobName/api/json?pretty=true 获取任务信息\ncurl -X POST http://localhost:8080/jenkins/job/jobName/build 触发构建，API 返回码是 201\n``\ncurl -X POST http://localhost:8080/jenkins/job/jobName/submitDescription?description=hello 添加描述信息\ncurl -X POST http://localhost:8080/jenkins/job/jobName/disable 禁用任务\ncurl -X POST http://localhost:8080/jenkins/job/jobName/enable 启用任务\ncurl -X POST http://localhost:8080/jenkins/job/jobName/doDelete 删除任务\n搜索任务 curl https://localhost:8080/jenkins/search/suggest?query=test 通过关键字搜索任务\n构建历史 curl http://localhost:8080/jenkins/job/jobName/1/consoleText 获取构建历史的控制台日志\ncurl http://localhost:8080/jenkins/job/jobName/1/logText/progressiveText?start=0 获取部分日志，并返回是否还有未输出的日志。协议头中的 X-Text-Size 为日志内容的大小，X-More-Data 的值如果为 true 的话则标示还有未输出的日志。\ncurl -X POST http://localhost:8080/jenkins/job/jobName/1/doDelete 删除构建历史\ncurl -X POST http://localhost:8080/jenkins/job/jobName/1/stop 停止构建\n下面是特定情况的构建：\ncurl http://localhost:8080/jenkins/job/jobName/lastBuild/consoleText 最近一次构建的日志\ncurl http://localhost:8080/jenkins/job/jobName/lastFailedBuild/consoleText 最近一次失败构建的日志\ncurl http://localhost:8080/jenkins/job/jobName/lastUnsuccessfulBuild/consoleText 最近一次未成功的构建日志\ncurl http://localhost:8080/jenkins/job/jobName/lastCompletedBuild/consoleText 最近一次完成的构建日志\n插件管理 curl -u admin:token http://localhost:8080/jenkins/pluginManager/uploadPlugin -F \u0026quot;name=@target/demo.hpi\u0026quot; 上传插件\n插件列表 /pluginManager/plugins\n重启 curl -X POST http://localhost:8080/jenkins/safeRestart 必须使用 POST 请求\n认证 这里既支持密码也支持 Token 的方式\ncurl http://localhost:8080/jenkins/job/jobName/api/json -u user:passwd\n在 HTTP 协议头中添加认证信息：\ncurl http://localhost:8080/jenkins/job/jobName/api/json --header \u0026#34;Authorization: Basic `echo -n user:passwd | base64`\u0026#34; https://129.28.182.197/jenkins/asynchPeople/api/json //user/admin/submitDescription //user/admin/delete //%s/user/%s/descriptorByName/jenkins.security.ApiTokenProperty/rename //%s/user/%s/descriptorByName/jenkins.security.ApiTokenProperty/Revoke\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/golang/slice/",
        "title": "Slice",
        "tags": [],
        "description": "Slice",
        "content": " codes/golang/slice/main.go package main import \u0026#34;fmt\u0026#34; func main() { demo4Array() demo4Map() } func demo4Map() { var strMap map[string]string strMap = make(map[string]string) strMap[\u0026#34;name\u0026#34;] = \u0026#34;link\u0026#34; fmt.Println(strMap) initMap := map[string]string{ \u0026#34;one\u0026#34;: \u0026#34;first man\u0026#34;, } fmt.Println(initMap) } func demo4Array() { var array []string array = make([]string, 1) array[0] = \u0026#34;one\u0026#34; array = append(array, \u0026#34;two\u0026#34;) array = append(array, \u0026#34;three\u0026#34;, \u0026#34;four\u0026#34;) others := []string{\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;} array = append(array, others...) fmt.Println(array) fmt.Println(len(array)) } 原文件 "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/golang/interface/",
        "title": "Interface",
        "tags": [],
        "description": "Interface",
        "content": "定义 type InterfaceTypeName interface { Print() } 实现方法的区别 type Demo struct{} func (i InterfaceTypeName) Print(){} type Demo2 struct {} func (i *InterfaceTypeName) Print(){} "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/java/",
        "title": "Java",
        "tags": [],
        "description": "Java",
        "content": "Java\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/java/java8/",
        "title": "Java8",
        "tags": [],
        "description": "Java 相关的内容总结",
        "content": "Lambda Collection 判断是否存在特定元素：\nSet\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); set.add(\u0026#34;a\u0026#34;); set.add(\u0026#34;b\u0026#34;); boolean exists = set.stream().anyMatch((a) -\u0026gt; a.startsWith(\u0026#34;a\u0026#34;)); System.out.println(exists); brew 我们可以通过 brew 来安装 java\nbrew cask install adoptopenjdk8\nExceptions 如果遇到下面在请求 HTTPS 时遇到证书的问题，可能是因为由于自制私有证书导致的。我们可以把私有证书导入 JRE 来解决：\nCaused by: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target 首先，要先找到 JRE 的位置：which java。目录通常是在：{{Installation_directory}}/{{JDK_version}}/jre/lib/security\n然后，导入证书：\nkeytool -importcert -file selfsigned.crt -keystore {{Installation_directory}}/{{JDK_version}}/jre/lib/security/cacerts\n在导入过程中，可能是需要有 root 权限，并要求输入证书密码。如果你在安装 Java 后没有修改过的话，默认的密码为：changeit。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/configuration/ini/",
        "title": "",
        "tags": [],
        "description": "",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/configuration/toml/",
        "title": "",
        "tags": [],
        "description": "",
        "content": "TOML TOML(Tom\u0026rsquo;s Obvious, Minimal Language) origin\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/configuration/yaml/",
        "title": "",
        "tags": [],
        "description": "",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/document/hugo/",
        "title": "",
        "tags": [],
        "description": "",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/document/markdown/",
        "title": "",
        "tags": [],
        "description": "",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/editor/eclipse/eclipse-plugin-dev/",
        "title": "",
        "tags": [],
        "description": "",
        "content": "Eclipse插件开发 类 ImageDescriptor 在 org.eclipse.jface 中。\n控制台 快捷键 Alt+Shift+F1 查看 UI 界面实现类\n构建 http://www.vogella.com/tutorials/EclipseTycho/article.html http://maven.apache.org/plugins/maven-eclipse-plugin/pde.html\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/network/chromedp/",
        "title": "",
        "tags": [],
        "description": "",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/translation/jenkins/releasing-experimental-updates/",
        "title": "",
        "tags": [],
        "description": "",
        "content": "发布实验性版本的插件 查看可用的开发者指导\nTo simplify delivery of beta versions of plugins to interested users, the Jenkins project published an experimental update center. It will include alpha and beta versions of plugins, which aren’t usually included in the regular update sites.\n创建试验性创建版本 Plugin releases that contain alpha or beta in their version number will only show up in the experimental update site. Note that it also serves regular releases, so the release of version 1.4 will result in 1.3-beta-2 no longer being available.\n配置 Jenkins 使用试验性更新中心 Users who are interested in downloading experimental plugin releases can go to Plugin Manager, then to the Advanced tab, and configure the update center URL https://updates.jenkins.io/experimental/update-center.json. Save, and then select Check Now. Experimental plugin updates will be marked as such on the Available and Updates tabs of the Plugin Manager.\nOnce you install the beta plugins that you wanted, you can switch back to the default https://updates.jenkins.io/update-center.json update center URL.\noriginal link\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/plugin-dev/jenkins-plugin-dev-action/",
        "title": "Action",
        "tags": [],
        "description": "Jenkins Plugin Action",
        "content": "本文介绍如果开发一个 Jenkins 的后端，也就是 Action。\n接口 你首先需要实现接口 hudson.model.Action 的三个方法:\ngetIconFileName getDisplayName getUrlName hudson.model.queue.FoldableAction\n约定 QueueAction hudson.model.Queue.QueueAction\n方法 shouldSchedule 会决定某一次构建是否会被调度，如果返回 false 的话，这次构建 动作就会被合并。通常情况下，对于用户触发两次构建，这两次之间没有任何变化的话，我们就 只需要构建一次即可，这样可以减少不必要的构建资源浪费。\nFoldableAction hudson.model.queue.FoldableAction\n"
    },
    {
        "uri": "https://linuxsuren.github.io/tags/agent/",
        "title": "agent",
        "tags": [],
        "description": "",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/k8s/ake/",
        "title": "Ake",
        "tags": [],
        "description": "一键安装 K8S",
        "content": "更新依赖 执行命令 yum upgrade libsepol libsemanage libselinux libsemanage libselinux audit-libs\nsudo apt-get update \u0026amp;\u0026amp; sudo apt-get install python -y\n安装 Support Docker versions ['1.12.6', '17.03.0', '17.03.1', '17.03.2', '17.12.0']\n通过命令 curl https://raw.githubusercontent.com/LinuxSuRen/getGo/master/jx-k8s.sh | bash -s ip 安装 Kubernetes\n修改配置文件 使用命令 vim ~/.kube/config，添加如下内容：\napiVersion: v1 clusters: - cluster: insecure-skip-tls-verify: true server: http://localhost:8080 name: local contexts: - context: cluster: local namespace: jx user: \u0026#34;\u0026#34; name: local current-context: local kind: Config preferences: {} users: - name: local user: as-user-extra: {} "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/plugin-dev/jenkins-plugin-dev-annotation/",
        "title": "Annotation",
        "tags": [],
        "description": "Jenkins 中的注解类介绍",
        "content": "CheckForNull Extension NoExternalUse Initializer Usage: @Initializer(after=InitMilestone.PLUGINS_PREPARED, fatal=false)\n通过该注解，可以实现在 Jenkins 的特定生命周期阶段来初始化特定方法。\nTerminator Usage: @Terminator(after=TermMilestone.STARTED)\n上面的示例中，表明了使得某个方法在 Jenkins 开始关闭时调用。\nRestricted Usage: @Restricted(NoExternalUse.class)\n上面的示例中，表明了某个方法不允许被直接调用，通常在接口回调中使用。\nWhitelisted org.jenkinsci.plugins.scriptsecurity.sandbox.whitelists.Whitelisted\nJenkins 流水线中的 DSL 语句，会收到沙盒机制的保护。你可能会见到类似如下的错误：\nScripts not permitted to use method groovy.lang.GroovyObjecgt invokeMethod Administrators can decide whether to approve or reject this signature. 如果对应的方法是在自定义插件中实现的话，通过给对应的方法上增加 @Whitelisted 解决该问题。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/server/apache2/",
        "title": "Apache2",
        "tags": [],
        "description": "Apache2 配置",
        "content": "查看工作方式 apachectl -V | grep -i mpm\n配置文件如下：\n\u0026lt;IfModule mpm_prefork_module\u0026gt; StartServers 10 # 启动时进程数 MinSpareServers 5 # 最小空闲进程数 MaxSpareServers 10 # 最大空闲进程数 MaxRequestWorkers 100 # 最大并发进程数 MaxConnectionsPerChild 10000 # 最大连接数限制 \u0026lt;/IfModule\u0026gt; "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/k8s/apiserver/",
        "title": "ApiServer",
        "tags": [],
        "description": "ApiServer",
        "content": "类型查看 查看所有的资源组 curl --insecure https://localhost:6443/apis/ | grep groupVersion | sort\n执行命令 curl --insecure https://localhost:6443/apis/{api.group}/{version} 可以看到所支持的资源类型\n认证 首先，需要从 Secret 中获取 Token，参考命令如下：\nkubectl get secret default-token-m99lz -o jsonpath={.data.token} | base64 --d \u0026gt; token\n上面的命令，我们从当前的命名空间（namespace）里默认的 Secret 中获取 Token，进行 base64 解密后保存为文件。\n然后，通过如下类似的命令即可访问到集群的 API：\ncurl -k https://localhost:6443/api/v1/namespaces --header \u0026#34;Authorization: Bearer `cat token`\u0026#34; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;admonition-content\u0026quot;\u0026gt; 需要确保的是，所使用 Token 对应的 ServiceAccount 具有所访问的资源的权限。\nRestful k8s.io/apiserver/pkg/registry/rest.NamedCreater POST 类的接口\nk8s.io/apiserver/pkg/registry/rest.GetterWithOptions GET 类的接口\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/editor/vim/core/vim-auto-complete/",
        "title": "Auto complete",
        "tags": [],
        "description": "Auto complete",
        "content": "Ctrl+X+P 整行\nCtrl+X+N 当前文件\nCtrl+X+K 字典\nCtrl+X+I 当前以及包含的文件\nCtrl+X+F 文件名\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/awk/",
        "title": "AWK",
        "tags": [],
        "description": "AWK",
        "content": "列出第一列 docker ps | grep hello | awk '{print $1}'\n特殊字符 有些情况下，我们要打印出一些特殊字符，下面给出一些示例来。\n冒号 docker images | grep jenkins | awk '{print $1\u0026quot;:\u0026quot;$2}'\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/banana-pi/",
        "title": "BananaPi",
        "tags": [],
        "description": "BananaPi",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/base64/",
        "title": "Base64",
        "tags": [],
        "description": "Base64",
        "content": "加密 echo -n 1234 | base64 这里的参数 n 很重要，如果没有的话，会把换行符也包含进去。\n解密 echo MTIzNA== | base64 --d\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/mac/brew/",
        "title": "Brew",
        "tags": [],
        "description": "Brew",
        "content": "brew 是 MacOS（或者 Linux 操作系统）下的缺省包管理器。\n在有 ruby 环境的操作系统中，可以使用下面的命令快速安装 brew：\n/usr/bin/ruby -e \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\u0026quot;\n其他的安装方式，请参考这里。\n安装软件 根据来源的不同，brew 包括两类软件，分别是：core、thridparty。\ncore 如果你不知道有哪些软件是可以直接安装的话，可以通过搜索命令来搜索：\nbrew search curl\n如果可以找到的话，就能用下面的命令来安装：\nbrew install curl\nthridparty 如何你想要把自己开发的命令行工具可以使用 brew 来安装，也是非常的简单，只要在 GitHub 中提供一个 ruby 文件即可，具体可以参考 homebrew-jcli。那么，对于这种第三方的命令行如何安装呢，也是非常简单，请参考下面 jcli 的例子：\nbrew tap jenkins-zh/jcli brew install jcli 其他操作 命令 描述 brew remove jcli 删除软件 brew upgrade jcli 升级软件 brew list 列出来已经安装的 brew info jcli 查看安装信息 brew deps jcli 查看依赖 brew outdated 查看可更新的软件 brew --repo 查看本地目录 代理 替换上游：\ngit -C \u0026#34;$(brew --repo)\u0026#34; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git git -C \u0026#34;$(brew --repo homebrew/core)\u0026#34; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git git -C \u0026#34;$(brew --repo homebrew/cask)\u0026#34; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask.git brew update 复原：\ngit -C \u0026#34;$(brew --repo)\u0026#34; remote set-url origin https://github.com/Homebrew/brew.git git -C \u0026#34;$(brew --repo homebrew/core)\u0026#34; remote set-url origin https://github.com/Homebrew/homebrew-core.git git -C \u0026#34;$(brew --repo homebrew/cask)\u0026#34; remote set-url origin https://github.com/Homebrew/homebrew-cask.git brew update 参考资料：https://mirror.tuna.tsinghua.edu.cn/help/homebrew/\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/centos/",
        "title": "CentOS",
        "tags": [],
        "description": "CentOS",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/cross/cicd/",
        "title": "CICD tools overview",
        "tags": [],
        "description": "A collection of some CICD platform or tools",
        "content": " Name Description Jenkins Jenkins automation server Tekton A K8s-native Pipeline resource drone Drone is a Container-Native, Continuous Delivery Platform JX Jenkins X provides automated CI+CD for Kubernetes with Preview Environments on Pull Requests using Tekton, Knative, Prow, Skaffold and Helm Fundation CD Fundation is a Neutral Home for the Next Generation of Continuous Delivery Collaboration\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/plugin-dev/jenkins-plugin-dev-cli/",
        "title": "CLI",
        "tags": [],
        "description": "Command Line Interface",
        "content": "扩展点 hudson.cli.CLICommand\nReference http://wiki.jenkins-ci.org/display/JENKINS/Writing+CLI+commands\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/team/codes-vs-documents/",
        "title": "Codes Vs Documents",
        "tags": [],
        "description": "Codes Vs Documents",
        "content": "除了 API 文档（可以自动生成）以外，我们在项目中还经常需要一些说明性的文档。例如：描述项目的结构、快速入门等等。因此，我建议项目目录中，以某种目录结构来编写相应的 Markdown 文件来说明这些。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/jenkins-plugin/configuration-as-code/",
        "title": "Configuration as Code",
        "tags": [],
        "description": "Jenkins Configuration as Code Plugin",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/mobile/",
        "title": "Connect to Mobile",
        "tags": [],
        "description": "How to connect mobile device",
        "content": "iPad 安装依赖的工具：\nadd-apt-repository ppa:pmcenery/ppa apt-get update apt-get install libimobiledevice-utils apt-get install ideviceinstaller 安装应用 ideviceinstaller -i xxx.ipa\n卸载应用 ideviceinstaller -U [bundleID]\n查看系统日志 idevicesyslog\n查看当前已连接的设备的UUID idevice_id --list\n截图 idevicescreenshot\n查看设备信息 videviceinfo\n获取设备时间 idevicedate\n参考 https://github.com/LinuxSuRen/libimobiledevice\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/editor/vim/plugins/vim-ctrlp/",
        "title": "ctrlp",
        "tags": [],
        "description": "ctrlp",
        "content": "Reference ctrlp\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/curl/",
        "title": "curl",
        "tags": [],
        "description": "curl",
        "content": "GET 使用 GET 方法请求一个URL地址 curl http://baidu.com\nPOST curl -d \u0026quot;param\u0026quot; http://baidu.com\ncurl -H \u0026quot;Content-Type:application/json\u0026quot; -X POST -d \u0026quot;param\u0026quot; http://baidu.com\ncurl --header \u0026#34;Authorization: Bearer $token\u0026#34; --insecure https://localhost:6443/apis/devops.alauda.io/v1alpha1namespaces/zxj/jenkinsbindings/hao/proxy -X POST -H \u0026#34;Content-Type:application/json\u0026#34; --data \u0026#39;{\u0026#34;url\u0026#34;:\u0026#34;alauda/cronTabCheck?cronText=sdf\u0026#34;}\u0026#39; 管道 我们可以通过 curl 下载并执行脚本，例如： curl http://test.com/test.sh | bash -s arg1\ncurl http://admin:admin@chartmuseum.jx.k1.surenpi.com/api/charts -F \u0026quot;chart=@jenkins-x-platform-0.0.1607.tgz\u0026quot;\n状态码 curl -I -m 10 -o /dev/null -s -w %{http_code} www.baidu.com 这样获取 HTTP 状态码\n输出格式 支持的变量包括：\ncontent_type filename_effective http_code http_connect http_version 代理 curl 默认会从环境变量中获取代理配置信息，但如果给定了参数 --proxy 的话，就会使用参数中给定的。\nLinux 下，添加环境环境变量为：export http_proxy=127.0.0.1:8080 以及 export https_proxy=127.0.0.1:8080。这里需要注意的是：HTTP_PROXY 是不支持的。\n语法：curl --proxy \u0026lt;[protocol://][user:password@]proxyhost[:port]\u0026gt; url\n示例：curl --proxy http://user:password@proxyhost:port http://yourserver.com\n我们可以使用 Nginx 作为一个代理服务器，参考配置如下：\nserver { resolver 8.8.8.8; listen 8080; location ~ .*/releases/.* { proxy_pass https://nexus.xxx.xxx/repository/github-proxy$request_uri; } location / { proxy_pass http://$http_host$request_uri; } } "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/golang/dep/",
        "title": "dep",
        "tags": [],
        "description": "dep",
        "content": "dep ensure -update\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/editor/vim/core/vim-dir/",
        "title": "Directory",
        "tags": [],
        "description": "Directory",
        "content": ":pwd 查看当前目录\n:cd %:p:h 切换目录到当前文件所在目录\n:lcd %:p:h 切换当前窗口的目录到当前文件所在目录\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/java/docker/",
        "title": "Docker",
        "tags": [],
        "description": "Docker",
        "content": "内存限制 镜像 8u151-alpine 在 JVM 的内存使用上有一些限制，它会限制 JVM 使用的最大内存为机器的 1/4。我们可以使用 8u171 以后的版本来解决这个问题。\n参考 Docker OpenJDK\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/docker/docker-api/",
        "title": "Docker api",
        "tags": [],
        "description": "Docker Api",
        "content": "获取 Token：\ncurl -X POST https://hub.docker.com/v1/users/login -d '{\u0026quot;username\u0026quot;:\u0026quot;user\u0026quot;,\u0026quot;password\u0026quot;:\u0026quot;password\u0026quot;}' -H 'Content-Type: application/json'\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/docker/docker-daemon/",
        "title": "Docker Daemon",
        "tags": [],
        "description": "Docker Daemon",
        "content": "API 通过命令 /usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:1234 启动 Docker Daemon 的话，可以设置 API 的访问。\nDocker Version vs API Version\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/docker/docker-mirror/",
        "title": "Docker Mirror",
        "tags": [],
        "description": "Docker Mirror",
        "content": "vim /etc/docker/daemon.json\n{ \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://mirror.gcr.io\u0026#34;] } 或者，获取在 daemon 启动时传递参数 dockerd --registry-mirror=https://mirror.gcr.io\n或者，在文件 /etc/default/docker 中添加如下配置：\nDOCKER_OPTS=\u0026quot;${DOCKER_OPTS} --registry-mirror=https://mirror.gcr.io\u0026quot;\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/docker/multi-stage/",
        "title": "Docker multi-stage technology",
        "tags": [],
        "description": "Docker multi-stage technology",
        "content": "We can build our application in Dockerfile. But we don\u0026rsquo;t want the whole thing in our final docker image. Docker multi-stage technology could help us the reduce the size.\nFROM golang:1.12 AS builder WORKDIR /work RUN git clone https://github.com/devops-ws/learn-pipeline-go \u0026amp;\u0026amp; \\ cd learn-pipeline-go \u0026amp;\u0026amp; go build -o go-server RUN ls -hal FROM alpine:3.10 COPY --from=builder /work/learn-pipeline-go/go-server . CMD [\u0026#39;go-server\u0026#39;] After built this: docker build . -t go-server\nthen we can test it: docker run go-server\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/docker/docker-oper/",
        "title": "Docker Operation",
        "tags": [],
        "description": "Docker Operation",
        "content": "Filter Images 当前支持的过滤如下：\ndangling（布尔值，true 或 false） label（label= 或 label== 删除包含制定字符串的镜像 docker rmi $(docker images | grep jenkinsx | awk '{print $3}')\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/docker/docker-base/",
        "title": "Docker 基础镜像",
        "tags": [],
        "description": "Docker 基础镜像",
        "content": "通常情况下，我们自己的镜像都会依赖于某个基础镜像。下面，是我总结的一些基础镜像。\nAlpine alpine 是一个非常轻量级的 Docker 镜像，大概只有 5.55MB 的大小。它包含一些比较常用的 Linux 命令。\nbash 是很多人使用的 shell，但是，默认（sh）情况下，alpine 并不包含 bash。 如果我们直接在 alpine 中执行 bash 命令的话，可能会报一些貌似没有道理的错误。其实， 你只要在 Dockerfile 中安装一下 bash 即可，下面给出一个示例：\nFROM alpine:latest RUN apk add bash "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/docker/docker-image/",
        "title": "Docker 镜像管理",
        "tags": [],
        "description": "Docker 镜像管理",
        "content": "使用 Docker 一段时间后，就会发现 Docker 镜像会占用很多的存储空间，我们可以通过 prune 命令来清理掉不再使用的镜像 docker image prune\n修改 Docker 镜像可以和 Git 一样，进行修改，然后重新推送回去。\n首先，运行一个镜像 docker run -it demo:v1.0 bash\n然后，通过名称等方式获取对应容器的 ID docker ps | grep demo:v1.0\n在之前的容器中，做一些修改，例如：添加一个文件 touch demo\n最后，把修改提交 docker commit -m 'fix something' f6591bcdce2c demo:v1.0。如果有需要的话，可以再把修改后的镜像推送回去 docker push demo:v1.0\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/docker/docker/",
        "title": "Docker 命令",
        "tags": [],
        "description": "Docker 命令",
        "content": "拉取镜像 docker pull jenkins/jnlp-slave:alpine\ndocker pull hub.alauda.cn/jenkins-jnlp-slave\n启动 自启动 当 Docker 服务启动后，默认情况下，所有的容器都不会启动。如果在每次启动时 Docker 服务时，自动启动容器，可以通过添加下面的参数实现：\ndocker run jenkins --restart=always\n最简单的启动命令 docker run surenpi/hugo-docker\n容器停止后，自动删除 docker run --rm surenpi/hugo-docker\n设置名称 当你启动 Docker 容器后，容器的名称时随机生成的。为了方便后续的查找，我们可以通过参数给容器设置一个名称：\ndocker run jenkins --name ci-jenkins\n查看容器 我们可以使用命令 docker ps ，查看所有运行状态的容器。\n如果要查看所有（包括已经停止的）容器话，可以使用参数：docker ps -a。\n停止容器 我们可以使用命令 docker stop 94a5fa599b05 来停止容器。这里的参数，是容器的ID。当然，我们也可以把容器的名称作为参数。\n日志 docker logs -f 94a5fa599b05\n当一个容器运行当时间长了以后，就可能会由于日志输出积累过多导致日志文件占用过多的存储。我们可以通过下面的命令，简单地删除来自容器中的日志文件：\nfind /var/lib/docker/containers/ -type f -name \u0026quot;*.log\u0026quot; -delete\n删除容器 我们可以通过命令 docker rm 94a5fa599b05 删除一个容器。当然，前提条件是该容器处于已停止的状态。\n通过过滤镜像名称批量删除容器 docker stop $(docker ps | grep hello | awk '{print $1}') \u0026amp;\u0026amp; docker rm $(docker ps | grep hello | awk '{print $1}')\n删除所有已经停止的容器 docker rm $(docker ps -a | grep Exited | awk '{print $1}')\n标签 docker tag source-image target-image\n端口映射 docker -p 127.0.0.1🔢8080 run jenkins\n卷 查看容器所挂载的卷信息 docker inspect 421b094bf94a | grep Mounts -A 20\n讲本地的目录绑定到容器中 docker run -v /your/home:/var/jenkins_home jenkins:jenkins:lts\n构建 设置构建过程中的代理 docker build . --build-arg http_proxy=http://192.168.2.9:8123 --build-arg https_proxy=http://192.168.2.9:8123\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/docker/docker-time/",
        "title": "Docker 时间设置",
        "tags": [],
        "description": "Docker 时间设置",
        "content": "通过如下配置，就可以实现对容器内的时区设置：\nENV TZ=Hongkong RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime \u0026amp;\u0026amp; echo $TZ \u0026gt; /etc/timezone Java 如何运行的是 Java 程序的话，还可以通过命令行参数在运行时指定：\ndocker run -p 8888:8080 -e JAVA_OPTS=\u0026quot;-Duser.timezone=HongKong\u0026quot; jenkins/jenkins:lts\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/docker/dockerfile/",
        "title": "Dockerfile",
        "tags": [],
        "description": "Dockerfile",
        "content": "基础镜像 如果没有特殊要求的话，建议尽可能选择较小的基础镜像。例如：alpine。您可以参考下面的 Dockerfile 写法：\nFROM alpine:3.8\nProxy 如果执行 Docker 构建时，需要设置网络代理的化，可以在 Dockerfile 中添加下面的指令：\nENV HTTP_PROXY http://192.168.1.1:1234\n上面的方法，在容器运行期，也会走代理。如果只是希望在构建期间设置网络代理的化，可以把 ENV 设置为空：\nENV HTTP_PROXY \u0026quot;\u0026quot;\n但是，需要在构建时指定参数：docker build --build-arg HTTP_PROXY=http://192.168.1.1:1234\nEXPOSE 指定容器要暴露的端口，例如：EXPOSE 9898。在执行容器时，可以通过参数来自动暴露给一个本地的随机端口，例如：docker run -P sample\nRUN RUN 为 Docker 镜像在构建时执行的命令\nCMD CMD 为 Docker 镜像在运行时的执行入口，例如：CMD [\u0026quot;echo\u0026quot;, \u0026quot;hello\u0026quot;]\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/echo/",
        "title": "echo",
        "tags": [],
        "description": "echo",
        "content": "参数 -n 不换行\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/editor/eclipse/",
        "title": "Eclipse Plugin",
        "tags": [],
        "description": "Eclipse 的使用以及插件开发",
        "content": "Eclipse 的使用以及插件开发\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/ffmpeg/",
        "title": "ffmpeg",
        "tags": [],
        "description": "ffmpeg",
        "content": "静态水印 ffmpeg -y -i movieFile -vf \u0026quot;movie=watermark.png [watermark]; [in][watermark] overlay=x:y:opaque [out]\u0026quot; movieWatermark.mp4\nffmpeg -i jenkins.mov -i watermark.png -filter_complex \u0026quot;overlay=10:10\u0026quot; jenkins.mp4\n动态水印 ffmpeg -y -i movieFile -ignore_loop 0 -i gif.gif -ss start -t duration -filter_complex overlay=0:0:1 movieGifFile\nhttp://ksloan.net/watermarking-videos-from-the-command-line-using-ffmpeg-filters/\n合并视频 把视频文件按照顺序写入 files.txt，然后执行命令：\nffmpeg -f concat -i files.txt -c copy jenkins-basic-install.mp4\n格式转换 通过下面的命令，可以实现视频格式的转换：\nffmpeg -i demo.mkv -codec copy demo.mp4\n修改分辨率 通过下面的命令可以实现视频文件的分辨率修改：\nffmpeg -i demo.mp4 -vf scale=1920:1080 demo.high.mp4\n图片缩放 假设图片 input.jpg 的尺寸为：320⨉207\nffmpeg -i input.jpg -vf scale=320:240 output_320x240.png 强制设置图片的尺寸\nffmpeg -i input.jpg -vf scale=320:-1 output_320.png 保留缩放比（输入和输出文件不能相同），输出的图片尺寸为：320⨉207\nffmpeg -i input.jpg -vf scale=320:-2 output_320.png 这样可以让图片的宽、高都被 n 整除，输出的图片尺寸为：320⨉206\nffmpeg -i input.jpg -vf scale=iw*2:ih input_double_width.png 使用变量设置宽、高，iw 代表输入的宽度，ih 代表输入的高度\nffmpeg -i input.jpg -vf \u0026quot;scale=iw/2:ih/2\u0026quot; input_half_size.png 使得图片的宽、高为原来的一半\nffmpeg -i input.jpg -vf \u0026quot;scale='min(320,iw)':'min(240,ih)'\u0026quot; input_not_upscaled.png\nffmpeg -i input.jpg -vf scale=w=320:h=240:force_original_aspect_ratio=decrease output_320.png\nffmpeg -i input.jpg -vf \u0026quot;scale=320:240:force_original_aspect_ratio=decrease,pad=320:240:(ow-iw)/2:(oh-ih)/2\u0026quot; output_320_padding.png\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/find/",
        "title": "Find",
        "tags": [],
        "description": "Find",
        "content": "查找大文件 find / -type f -size +500M 这里的 f 指的是文件类型，并且，大于500M的。而且，字母 M 是大写。\n查找文件夹 find ~ -type d -name jx\n查找并执行命令 find . -name *.java | xargs echo 查找完后执行\n查找特定文件 cp $(find core/src/main/resources -type f -name \u0026quot;*_zh_CN.properties\u0026quot;) /tmp\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/browser/firefox/",
        "title": "Firefox",
        "tags": [],
        "description": "Firefox",
        "content": "firefox -private\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/centos/firewall/",
        "title": "Firewall",
        "tags": [],
        "description": "Firewall",
        "content": "systemctl stop firewalld.service 停止firewall\nsystemctl disable firewalld.service 禁止firewall开机启动\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/cross/",
        "title": "General topic About DevOps",
        "tags": [],
        "description": "General topic About DevOps",
        "content": "General topic About DevOps\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/scm/git/git-branch/",
        "title": "Git Branch",
        "tags": [],
        "description": "Git Branch",
        "content": "切换标签 git branch 列出本地分支 git checkout master 切换到本地 master 分支\n删除分支 git branch --delete abc 删除分支 abc\ngit push origin --delete abc 删除远程分支\ngit branch -v | grep gone | awk '//{print $1}' | xargs git branch -d 删除远程分支不存在的`\ngit remote prune origin\n拉取分支 git checkout -b abc 基于当前分支创建新分支\ngit checkout --track origin/abc 拉取远程分支\n推送分支 git push origin local-branch:remote-branch 推送本地分支到远程上不同的分支\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/team/git-collaborate/",
        "title": "Git Collaborate",
        "tags": [],
        "description": "Git Collaborate",
        "content": "几乎所有的团队都有自己的沟通系统（工具），像 Jira、Kanban、微信、钉钉等等。而我现在要说的是像 GitHub、Gitlab 等 Git 服务提供的 PR。代码 Review 是件好事情，这一点很多人都认同，但是很明显的痛点在于——这样可能会比较耗时。\n大家不一定能够在看到邮件、钉钉等的消息后，就立刻去做 Review，因此，很多时候就会忘记从而导致这个过程加长。\n如果，能够给每个项目都指定一些必须要进行 Review 的人员，然后，自动地把 PR 的 Review 需求加到像 Jira 这样的任务跟踪系统中的。对，关键点就在于把 Review 也正式地当作工作任务的一部分。\n我相信，这样也许就能解决大家的代码都能够相对高效地被 Review呢。而且，这样也对 Review 的工作量相对可控。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/scm/git/git-rebase/",
        "title": "Git Rebase",
        "tags": [],
        "description": "Git Rebase",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/scm/git/git-remote/",
        "title": "Git Remote",
        "tags": [],
        "description": "Git 远程库操作",
        "content": "git remote show origin 可以查看仓库的分支信息，虽然另外一条命令 git branch -a 能看到所有的远程分支列表，但缺点是无法看到哪些分支是被删除了的。\n这里的场景是：当你建立的feature或者fix分支被合并到了master后，通常会把该分支（远程）删除。那么，本地的分支实际上已经没有了远程所对应的分支了。如果，我们不把本地的分支删除的话，就会导致本地分支的数量越来越多，难以管理。通过上面的命令，我们可以很清晰地看到有哪些远程分支已经被删除。然后，通过下面的命令来清理本地的陈旧分支。\ngit remote prune origin 该命令会立即把所有需要修剪（prune）的分支删除。但，如果我们还希望能在删除之前查看有哪些会被删除的话可以执行下面的命令：\ngit remote prune origin --dry-run 当然，origin 这里就是远程库的名称，你可以换成你实际的远程库名称。\n最后，你还需要再把本地的分支删除，命令是 git branch --delete dev。\n多个远程库 我们可以在本地 git 仓库中，添加多个远程仓库，请参考下面的命令：\ngit remote add origin https://github.com/jenkins-zh/jenkins-cli git remote add gitee https://gitee.com/jenkins-zh/jenkins-cli.git 当我们执行命令 git push 时，默认会把当前分支推送到所关联的远程仓库中，这里通常会是 origin。\n如果，我们希望能同时把代码推送到多个远程仓库中的话，可以先执行如下的命令\ngit remote set-url --add --push origin https://github.com/jenkins-zh/jenkins-cli git remote set-url --add --push origin https://gitee.com/jenkins-zh/jenkins-cli.git 我们也可以通过下面的命令删除上面的配置\ngit remote set-url --delete --push origin https://gitee.com/jenkins-zh/jenkins-cli.git\n删除远程仓库 我们可以通过下面的命令，删除一个远程仓库：\ngit remote remove gitee\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/scm/git/git-reset/",
        "title": "Git Reset",
        "tags": [],
        "description": "Git Reset",
        "content": "撤销对某个文件的修改 当发现某次 Git 提交中，包含了错误的修改记录，可能误删文件、多提交了文件等。这时候，可以按照如下的流程把提交记录进行修改：\n首先，获取某个文件的提交记录，命令为：git log \u0026lt;filename\u0026gt;\n找到需要恢复到的那次提交记录，执行撤销命令： git reset \u0026lt;commit-id\u0026gt; \u0026lt;filename\u0026gt; 然后 git checkout \u0026lt;filename\u0026gt;\n最后，确认修改：git commit --amend \u0026amp;\u0026amp; git push\n如果在上述的操作之前，push 过的话，记得再次 push 时需要添加 -f 参数。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/scm/git/git-stage/",
        "title": "Git Stage",
        "tags": [],
        "description": "Git Stage",
        "content": "我们提交文件，要先执行 git add 然后再执行 git commit。但是，如果在执行 commit 时，发现由于误操作导致一些不希望提交的文件也被 add 了。这时候，我们可以执行命令 git reset HEAD readme.md 来取消该操作。\ngit checkout readme.md 可以把 unstage 状态的文件修改丢弃\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/scm/git/git-submodule/",
        "title": "Git Submodule",
        "tags": [],
        "description": "Git 子模块的使用",
        "content": "子模块 克隆含有子模块的项目 需要在子模块目录中执行命令 git submodule init\nget submodule update 更新子模块代码\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/scm/git/git-tag/",
        "title": "Git 标签（tag）",
        "tags": [],
        "description": "Git 标签（tag）的相关操作",
        "content": "标签 git tag v0.1.2-light\ngit tag -a v0.2 -m 'here is comment'\n切换到标签 git checkout v0.2\n删除标签 git tag -d v0.2\n基于提交记录打标签及 git tag -a v0.2 beab786 -m 'from branch hello beab786'\n发布指定的标签 git push origin v0.2\n把所有的标签一次性发布 git push origin --tags\ngit可以在同一个提交上打多个名称不一样的标签\n获取远程标签 git fetch --all --tags 这样会获取所有远程库的所有标签（tag）\n删除远程标签 git push --delete origin tagname 删除远程的指定标签\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/scm/git/git-proxy/",
        "title": "Git 代理",
        "tags": [],
        "description": "配置 Git 使用代理",
        "content": "全局代理 git config --global http.proxy http://proxyUsername:proxyPassword@proxy.server.com:port\n部分代理 我们也可以对指定的域名配置代理，格式为：git config --global http.https://github.com.proxy http://proxyUsername:proxyPassword@proxy.server.com:port\ngit config --global http.https://github.com.proxy 127.0.0.1:1087 git config --global http.https://github.com.sslVerify false 查看配置 git config --global --get-regexp http.* git config --get-regexp http.* 取消代理 git config --global --unset http.proxy git config --global --unset http.https://domain.com.proxy git config --global --unset http.sslVerify git config --global --unset http.https://domain.com.sslVerify "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/scm/gitea/",
        "title": "Gitea",
        "tags": [],
        "description": "Gitea",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/scm/gitea/gitea/",
        "title": "Gitea",
        "tags": [],
        "description": "",
        "content": "docker pull gitea/gitea:latest\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/scm/gitlab/gitlab/",
        "title": "Gitlab",
        "tags": [],
        "description": "Gitlab 使用介绍",
        "content": "Docker 我们可以在 Docker 中运行 Gitlab。首先，要拉取镜像 docker pull gitlab/gitlab-ce。\n启动容器的命令 docker run -d -p 1234:80 --rm gitlab/gitlab-ce\nGitlab 在 DockerHub 上的地址 https://hub.docker.com/r/gitlab/gitlab-ce/\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/scm/gitlab/",
        "title": "GitLab",
        "tags": [],
        "description": "GitLab",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/golang/glide/",
        "title": "glide",
        "tags": [],
        "description": "glide",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/golang/godep/",
        "title": "godep",
        "tags": [],
        "description": "godep",
        "content": "godep update foo/bar\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/packagemanager/gofish/",
        "title": "GoFish",
        "tags": [],
        "description": "GoFish",
        "content": "curl -fsSL https://raw.githubusercontent.com/fishworks/gofish/master/scripts/install.sh | bash\nhttps://gofi.sh/\nhttps://github.com/fishworks/fish-food\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/golang/go/",
        "title": "golang",
        "tags": [],
        "description": "golang",
        "content": "Environment 环境变量 GOROOT 是 Golang 的安装根目录\n环境变量 GOPATH 是 Golang 的包依赖目录，包括的目录有：\nsrc 源码 bin 执行 go get 等命令的二进制文件下载目录 pkg 生成编译文件的目录 GOGC GOGC 是用来控制内存垃圾回收（GC）被触发时的比例，默认值为：GOGC=100。GOGC=off可以完全关闭垃圾回收。\nProxy 在使用命令 go get xxx 时，如果需要翻墙的话，可以考虑下面的方案\n设置全局代理 git config --global http.proxy 'http://192.168.2.9:8123'\n设置忽略的代理 git config --global no.proxy '*.github.com'\nPackage import If you want to use a custom domain in your Go import path, please read more about govanit. Here is a blog related with it.\nA online service of Go Vanity Server.\nTroubleshooting --oom-kill-disable=false\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/golang/json/",
        "title": "Golang with JSON",
        "tags": [],
        "description": "Golang with JSON",
        "content": " /codes/golang/json/main.go package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;log\u0026#34; ) func main() { jsonStr := ` [\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;] ` var array []string err := json.Unmarshal([]byte(jsonStr), \u0026amp;array) if err != nil { log.Println(err) } else { log.Println(array) } } 原文件 数据格式转换 下面的例子中，可以将 JSON 中同一个字段不同数据类型统一转换为字符串格式\n/codes/golang/json-marshal/main.go package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;strings\u0026#34; ) var json_str = `{ \u0026#34;value\u0026#34;: \u0026#34;GOOD\u0026#34;, \u0026#34;name\u0026#34;:\u0026#34;name\u0026#34; }` var json_bool = `{ \u0026#34;value\u0026#34;: false, \u0026#34;name\u0026#34;:\u0026#34;good\u0026#34; }` type Form struct { Value ComposeValue Name string } type ComposeValue struct { Value string } func (f *ComposeValue) UnmarshalJSON(data []byte) error { originStr := strings.Trim(string(data), `\u0026#34;`) switch str := strings.ToLower(originStr); str { case \u0026#34;true\u0026#34;: f.Value = \u0026#34;true\u0026#34; case \u0026#34;false\u0026#34;: f.Value = \u0026#34;false\u0026#34; default: f.Value = originStr } return nil } func (f ComposeValue) MarshalJSON() ([]byte, error) { return json.Marshal(f.Value) } func (f ComposeValue) String() string { return f.Value } func main() { var data []byte var err error form := \u0026amp;Form{} if err := json.Unmarshal([]byte(json_str), form); err != nil { log.Fatal(err) } if data, err = json.Marshal(form); err != nil { log.Fatal(err) } fmt.Println(string(data)) if err := json.Unmarshal([]byte(json_bool), form); err != nil { log.Fatal(err) } data, _ = json.Marshal(form) fmt.Println(string(data)) } 原文件 "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/golang/goroutines/",
        "title": "GoRoutines",
        "tags": [],
        "description": "GoRoutines",
        "content": "简单例子 "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/golang/govendor/",
        "title": "govendor",
        "tags": [],
        "description": "govendor",
        "content": "govendor init\ngovendor list\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/gpg/",
        "title": "GPG",
        "tags": [],
        "description": "GPG",
        "content": "安装 Windows版本下载地址 https://www.gpg4win.org/download.html\nUbuntu下安装 sudo apt-get install gpg -y\nMac下安装 brew install gpg 或者从 https://gpgtools.org/ 下载\n从 https://sourceforge.net/p/gpgosx/docu/Download/ 下载 gpg2\n命令 gpg --export-secret-key 标识名 \u0026gt; 导出文件名\ngpg -o keyfilename --export-secret-keys KeyID\ngpg -o keyfilename --export KeyID\ngpg --import 密钥文件\ngpg --list-keys 列出密钥\ngpg --delete-secret-key hello\ngpg --delete-key hello\n上传公钥 gpg --keyserver hkp://pool.sks-keyservers.net --send-key 1234567\n接收公钥 gpg --keyserver pool.sks-keyservers.net --recv-key 1234567\ngpg --keyserver hkp://keyserver.ubuntu.com --search-keys 1234567 搜索公钥\n公钥服务器 hkp://pool.sks-keyservers.net\nhkp://subkeys.gpg.net\nhkp://keyserver.ubuntu.com\n加解密 gpg --recipient 1234567 --output a-encrypt.log --encrypt a.log 加密文件\ngpg a-encrypt.log 解密文件\ngpg --decrypt a-encrypt.log 解密文件\n签名 gpg --sign a.log 生成二进制签名文件 a.log.gpg\ngpg --clearsign a.log 生成 ASCII 签名文件 a.log.asc\ngpg --detach-sign a.log 生成单独的二进制签名文件 a.log.sig\ngpg --armor --detach-sign a.log 生成单独的 ASCII 签名文件 a.log.asc\ngpg --verify a.log.asc 验证签名\ngpg --local-user 1234567 --recipient 1234567 --armor --sign --encrypt a.log 签名并加密\n异常 gpg: cannot open /dev/tty\u0026#39;: No such device or address can\u0026#39;t connect to /root/.gnupg/S.gpg-agent’: No such file or directory gpg: can’t connect to the agent: IPC connect call failed gpg: signing failed: No secret key 如果是用 Maven 插件的话，可以参考下面的配置：\n\u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-gpg-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.6\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;sign-artifacts\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;verify\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;sign\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;gpgArguments\u0026gt; \u0026lt;arg\u0026gt;--pinentry-mode\u0026lt;/arg\u0026gt; \u0026lt;arg\u0026gt;loopback\u0026lt;/arg\u0026gt; \u0026lt;arg\u0026gt;--no-tty\u0026lt;/arg\u0026gt; \u0026lt;/gpgArguments\u0026gt; \u0026lt;interactive\u0026gt;false\u0026lt;/interactive\u0026gt; \u0026lt;passphrase\u0026gt;1233\u0026lt;/passphrase\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/grep/",
        "title": "grep",
        "tags": [],
        "description": "grep",
        "content": "反向查找 查找不包含特定字符的数据 ps -ef | grep -v running\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/docker/multi-arch-image/",
        "title": "How to build a multi-arch docker image",
        "tags": [],
        "description": "How to build a multi-arch docker image",
        "content": "Install multi-arch binary files in one Dockerfile FROM ubuntu RUN ARCH= \u0026amp;\u0026amp; ARCH_ALIAS= \u0026amp;\u0026amp; dpkgArch=\u0026#34;$(dpkg --print-architecture)\u0026#34; \\ \u0026amp;\u0026amp; case \u0026#34;${dpkgArch##*-}\u0026#34; in \\ amd64) ARCH=\u0026#39;amd64\u0026#39;;; \\ ppc64el) ARCH=\u0026#39;ppc64le\u0026#39;;; \\ s390x) ARCH=\u0026#39;s390x\u0026#39;;; \\ arm64) ARCH=\u0026#39;arm64\u0026#39;;; \\ armhf) ARCH=\u0026#39;armv7l\u0026#39;;; \\ i386) ARCH=\u0026#39;x86\u0026#39;;; \\ *) echo \u0026#34;unsupported architecture\u0026#34;; exit 1 ;; \\ esac \u0026amp;\u0026amp; \\ apt-get update \u0026amp;\u0026amp; apt-get install wget -y \u0026amp;\u0026amp; \\ wget https://cdn.jsdelivr.net/gh/jenkins-zh/jcli-repo/jcli-linux-$ARCH.tar.gz \u0026amp;\u0026amp; \\ tar xzvf jcli-linux-$ARCH.tar.gz \u0026amp;\u0026amp; rm -rf jcli-linux-$ARCH.tar.gz Save those content into Dockerfile, then execute command docker buildx build --platform linux/amd64,linux/arm64 . -f Dockerfile -t jcli:test\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/golang/http/",
        "title": "HTTP",
        "tags": [],
        "description": "HTTP",
        "content": " codes/golang/http/main.go package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;net/url\u0026#34; \u0026#34;strings\u0026#34; ) func main() { test() url := url.URL{ Host: \u0026#34;linuxsuren.github.io\u0026#34;, Path: \u0026#34;/index.json\u0026#34;, Scheme: \u0026#34;https\u0026#34;, } fmt.Println(url.RequestURI()) fmt.Println(url.String()) response, err := http.Get(url.String()) if err != nil { fmt.Printf(\u0026#34;get error %v\\n\u0026#34;, err) return } data, err := ioutil.ReadAll(response.Body) if err != nil { fmt.Printf(\u0026#34;read error %v\\n\u0026#34;, err) return } fmt.Println(string(data)) } func test() { data := `json={\u0026#34;parameter\u0026#34;:[{\u0026#34;name\u0026#34;:\u0026#34;name\u0026#34;,\u0026#34;value\u0026#34;:\u0026#34;bob\u0026#34;},{\u0026#34;name\u0026#34;:\u0026#34;age\u0026#34;,\u0026#34;value\u0026#34;:\u0026#34;12\u0026#34;}]}` inputURL := \u0026amp;url.URL{ Host: \u0026#34;jenkins.k8s.surenpi.com\u0026#34;, Path: \u0026#34;job/demo/job/demo-input-request-3/6/input/6be09e0ef4dcfd27eb2c985c3cff02ae/proceed\u0026#34;, Scheme: \u0026#34;http\u0026#34;, } fmt.Println(data) fmt.Println(inputURL) formData := url.Values{\u0026#34;json\u0026#34;: {`{\u0026#34;parameter\u0026#34;:[{\u0026#34;name\u0026#34;:\u0026#34;name\u0026#34;,\u0026#34;value\u0026#34;:\u0026#34;bob\u0026#34;},{\u0026#34;name\u0026#34;:\u0026#34;age\u0026#34;,\u0026#34;value\u0026#34;:\u0026#34;12\u0026#34;}]}`}} payload := strings.NewReader(formData.Encode()) fmt.Println(formData.Encode()) fmt.Println(payload) fmt.Println(inputURL.String()) request, err := http.NewRequest(http.MethodPost, inputURL.String(), payload) request.Header.Add(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/x-www-form-urlencoded\u0026#34;) request.SetBasicAuth(\u0026#34;user\u0026#34;, \u0026#34;passwd\u0026#34;) if err != nil { fmt.Println(err) } else { client := \u0026amp;http.Client{} resp, err := client.Do(request) if err != nil { fmt.Println(err) } else { data, _ := ioutil.ReadAll(resp.Body) fmt.Println(string(data)) } } } 原文件 创建 Response 结构 import ( \u0026#34;net/http\u0026#34; \u0026#34;io/ioutil\u0026#34; ) http.Response{ StatusCode: http.StatusOK, Body: ioutil.NopCloser(bytes.NewReader([]byte(\u0026#34;test\u0026#34;))), } "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/network/http_status/",
        "title": "HTTP Status",
        "tags": [],
        "description": "HTTP Status",
        "content": "200 300 400 401 未经授权：访问由于凭据无效被拒绝。\n404 无法找到页面\n500 Reference "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/editor/idea/",
        "title": "IDEA",
        "tags": [],
        "description": "IDEA",
        "content": "编辑器\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/k8s/ingress/",
        "title": "Ingress",
        "tags": [],
        "description": "Ingress",
        "content": "Controller 如何要利用 Ingress 来监听 80 端口的话，需要按照 Controller.\nRewrite Ingress 支持地址重写，具体请查看参考。\n413 在通过 Ingress 访问的系统中上传较大文件时，可能会遇到错误 Request Entity Too Large。\n这时，找到对应的 Ingress 添加如下 Annotations 即可解决：\ningress.kubernetes.io/proxy-body-size: \u0026#34;0\u0026#34; nginx.ingress.kubernetes.io/proxy-body-size: \u0026#34;0\u0026#34; nginx/client_max_body_size: \u0026#34;0\u0026#34; HTTPS 如果不希望自动跳转到 HTTPS 的话，可以添加如下的注解：\nnginx.ingress.kubernetes.io/ssl-redirect: \u0026quot;false\u0026quot;\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins-x/install/",
        "title": "Install",
        "tags": [],
        "description": "Jenkins X 部署教程",
        "content": "预备 Jenkins X 是基于容器化来实现的 CI/CD 平台，因此，我们首先需要搭建 Kubernetes 环境。\n安装依赖 安装 Git yum install git -y 安装 Maven yum install maven -y\nsudo apt-get install maven make -y\n为了方便，我们把当前用户加入 Docker 用户组 sudo gpasswd -a ${USER} docker\n重启 Docker 服务 sudo service docker restart\n添加权限 sudo chmod a+rw /var/run/docker.sock\n拉取镜像 执行命令 curl https://raw.githubusercontent.com/LinuxSuRen/getGo/master/jx-images.sh | bash 拉取 jx 所需要的镜像\n安装 jx 获取 jx curl -LO https://github.com/jenkins-x/jx/releases/download/$(curl -s https://api.github.com/repos/jenkins-x/jx/releases/latest | grep tag_name | cut -d '\u0026quot;' -f 4)/jx-linux-amd64.tar.gz | tar xzv\n移动到系统目录中 mv jx /usr/local/bin\n安装 jx jx install --username suren --provider=kubernetes --on-premise\n连接远程 如果我们想要从本地连接远程的 Kubernetes 集群的话，需要导出用户证书。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/docker/docker-ubuntu-install/",
        "title": "Install Docker",
        "tags": [],
        "description": "How to install docker in Ubuntu",
        "content": "查看可用的版本 apt-cache madison docker-ce\n安装指定版本 apt-get install docker-ce=17.12.0~ce-0~ubuntu\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/editor/idea/idea-shortcut/",
        "title": "IntelliJ IDEA 快捷键",
        "tags": [],
        "description": "IntelliJ IDEA 快捷键",
        "content": "Alt+Enter 快速修复（例如：快速地添加import、添加需要从接口中实现的方法等等） Alt+Insert 快速添加getter、setter、toString等方法 Ctrl+Shift+U 大小写切换 Ctrl+E 列出最近的文件 Ctrl+Q 快速显示注释文档 Ctrl+G 定位到行 Ctrl+X 删除行 Ctrl+N 类查找 Ctrl+Shift+Alt+N 方法查找 Ctrl+F12 方法查找 Ctrl+Shift+N 文件查找 Ctrl+Alt+B 定位到实现类中（或者Ctrl+Alt+Left Mouse） Ctrl+Alt+O 删除没有使用的import语句 "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/terminal/iterm2/",
        "title": "Iterm2",
        "tags": [],
        "description": "Iterm2",
        "content": "自动完成 CMD+;\nReference https://www.iterm2.com\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/build/java-annotation-processing-builder/",
        "title": "Java Annotation Processing and Creating a Builder",
        "tags": [],
        "description": "Java Annotation Processing and Creating a Builder",
        "content": "See also https://www.baeldung.com/java-annotation-processing-builder\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/basic/jenkins-agent/",
        "title": "Jenkins Agent",
        "tags": [],
        "description": "Jenkins Agent",
        "content": "Jenkins 的运行模式，分为 master 和 agent。配置、管理、调度等会由 master 节点来完成，而具体的构建任务则由计算节点（agent）完成。\n默认安装的 Jenkins 会包含一个 master 节点。通常，不会在 master 节点上执行构建任务，只用于调度。\nJenkins 的节点，通常可以配置如下属性：\n名称 唯一标示 描述 并发构建数 同一时刻可执行的任务数 远程工作目录 标签 空格分割的字符串，通常包含环境信息 启动方式 agent 节点如何启动，通常与 agent 类型相关 工具位置 构建工具的安装位置配置 环境变量 类型 Jenkins 支持多种与节点通信的方式。\nJNLP 默认支持。\nSSH 需要安装插件。\nDocker 这里指的是在 Docker 容器里运行 Jenkins 计算节点。我们可以分为两类：静态、动态。\n静态 Docker 静态的 Docker 容器，是通过命令来启动一个 jnlp 容器。这种方式与 JNLP 其实是相同的机制，都是需要提前在 Jenkins 的节点管理界面添加一个静态节点，然后再启动。\n通常的命令 docker run jenkins/jnlp-slave -url http://jenkins-server:port \u0026lt;secret\u0026gt; \u0026lt;agent name\u0026gt;\n设置 Tunnel 端口 docker run jenkins/jnlp-slave -tunnel :\u0026lt;tunnel port\u0026gt; -url http://jenkins-server:port \u0026lt;secret\u0026gt; \u0026lt;agent name\u0026gt;\n\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;admonition-content\u0026quot;\u0026gt; 注意，上面的端口是 Jenkins 的管理界面的端口，secret 则要从 JNLP 节点的状态页面获取，最后需要的是节点的名称。\n想了解源码的朋友，可以查看这里。\n动态 Docker 这种方式需要 Jenkins 所在的服务器上安装 Docker，它会在流水线执行时动态地创建、销毁容器。优点：无需提前启动计算节点，不依赖 Java 环境，不依赖 JNLP；缺点：架构上与 Docker 紧紧地绑定了，无法做到扩缩容。下面是一种直接指定 Docker 镜像的方式，还有另外一种方式支持动态构建出一个镜像：\ncodes/jenkinsfile/docker-agent.groovy pipeline { agent { docker { image \u0026#39;alpine:3.7\u0026#39; } } stages{ stage(\u0026#34;one\u0026#34;){ steps{ echo \u0026#34;hello\u0026#34; sh \u0026#39;uname -a\u0026#39; } } } } 原文件 Kubernetes 需要安装插件。\n这种动态调度节点的方式，在和使用静态节点的没有区别，都是通过 Jenkins 强大的标签机制来调度。而节点的扩缩容则交给了 K8S 集群。Jenkins 的 master 节点可以运行在任意环境里，这一点是没有任何限制。\n目前，也可能是较长时间内的一个缺点就是：复杂。不过，对于配置复杂的问题，可以借助配置及代码这个插件来解决。异常诊断的问题，也在积极的解决。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/plugin-dev/jenkins-plugin-handler/",
        "title": "Jenkins Handler",
        "tags": [],
        "description": "Jenkins Handler",
        "content": "该扩展点用于决定特定的任务是否会被调度\nhudson.model.Queue.QueueDecisionHandler\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/plugin-dev/jenkins-junit/",
        "title": "Jenkins JUnit",
        "tags": [],
        "description": "Jenkins JUnit",
        "content": "断言 @Test public void basic() { assertThat(\u0026#34;abc\u0026#34;, StringContains.containsString(\u0026#34;a\u0026#34;)); assertThat(\u0026#34;abc\u0026#34;, Matchers.not(StringContains.containsString(\u0026#34;d\u0026#34;))); assertTrue(true); assertFalse(false); assertNull(null); assertNotNull(\u0026#34;\u0026#34;); assertEquals(\u0026#34;a\u0026#34;, \u0026#34;a\u0026#34;); } 数据源 注解 @LocalData 会按照一定的规则去加载 src/test/resources 中的配置文件。\n例如：该注解加载类 org.test.TestAgent 的方法 test 上的话，就会去加载目录 src/test/resources/org/test/TestAgent/test 中的配置文件。另外，它还有一个 value 参数可以替代使用方法名称。\n框架 Jenkins 的测试框架为 acceptance-test-harness。\n在 pom.xml 中可以修改框架的版本，如下所示：\n\u0026lt;properties\u0026gt;\u0026lt;jenkins-test-harness.version\u0026gt;2.28\u0026lt;/jenkins-test-harness.version\u0026gt;\u0026lt;/properties\u0026gt; 通过下面的方式修改 Jenkins 运行测试的版本：\n\u0026lt;properties\u0026gt;\u0026lt;jenkins.version\u0026gt;2.150.1\u0026lt;/jenkins.version\u0026gt;\u0026lt;/properties\u0026gt; 环境变量 如果需要修改运行测试时的 Jenkins 版本，可以在启动 JVM 时指定参数 -Djth.jenkins-war.path=/tmp/jenkins.war\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/jenkins-plugin/kubernetes/",
        "title": "Jenkins Kubernetes Plugin",
        "tags": ["k8s", "plugin", "docker", "agent"],
        "description": "Jenkins Kubernetes Plugin",
        "content": " Kubernetes 是一个容器编排的系统，而 Kubernetes 插件则是 Jenkins 用来调度 K8S 以实现动态计算节点的方式。对 插件源码感兴趣的童鞋可以了解下。\n预备知识 要能够顺利地使用 Kubernetes 的 Jenkins 插件，必须对相关的一些基本知识所有了解。\nDocker 中的基本概念，例如：镜像、容器、卷（Volume）。熟悉如何拉取镜像，启动、停止、查看容器。\nKubernetes 中的基本概念，例如：命名空间（Namespace）、Pod、PodTemplate、Secret 等。熟悉命令行工具 kubectl 的一些基本操作，查看 Pod 列表、事件、日志等。\nJNLP 的基本原理。\n基本原理 当标签规则匹配到某个 Pod 模板时，插件会尝试根据该模板的配置启动一个 Pod。而该 Pod 在启动过程中，会通过 JNLP 协议来连接 master 节点。\n为了能够让 Pod 连接到 Jenkins 的 master 节点，我们首先需要在“全局安全配置”中开启 JNLP 代理协议，并记住端口。\n然后，在“系统配置”页面中的 Kubernetes 区域配置正确的 Jenkins 以及 JNLP 的地址以及端口。\n认证 有多种方式可以配置 Jenkins 与 Kubernetes 集群集成认证。最简单的就是添加凭据时选择 Secret File 类型，并把文件 ~/.kube/config 上传即可。这里有如何导出 k8s 集群认证文件的介绍。\n导出 Kubernetes 认证文件的命令：\ncurl https://raw.githubusercontent.com/LinuxSuRen/surenpi/master/static/codes/shell/k8s/export-k8s-crt.sh|bash\nPod 模板 一个 Pod 对应 Jenkins 中的一个执行节点，\nK8S 代理节点 该插件在流水线中以支持多种方式使用 K8S 代理节点。通常情况下，我们需要在 Pod 模板中添加一个容器模板，也就是所需要的运行环境，例如：Java、Golang 等语言相关的。在运行期，Kubernetes 插件会自动添加一个 JNLP 的容器。\n对于希望使用自定义 JNLP 镜像的用户来说，可以多添加一个 JNLP 镜像就可以覆盖了。\n多容器 Pod 里如果包含多个容器的话，在使用的过程中，要注意根据实际情况进行切换。对应的 DSL 语句如下：\ncontainer(\u0026#34;container_name\u0026#34;){ echo \u0026#34;hello\u0026#34; } 排错 "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/plugin-dev/jenkins-permission/",
        "title": "Jenkins Permission",
        "tags": ["Jenkins"],
        "description": "Jenkins Permission System",
        "content": "Jenkins.get().checkPermission(Jenkins.ADMINISTER);\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/pipeline/",
        "title": "Jenkins Pipeline",
        "tags": [],
        "description": "Jenkins Pipeline",
        "content": "Jenkins Pipeline 的使用和开发\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/plugin-dev/jenkins-plugin-dev-credential/",
        "title": "Jenkins Plugin Dev Credentails",
        "tags": [],
        "description": "Jenkins Plugin Dev Credentails",
        "content": "IdCredentials 规定了具有 ID 的凭据（Credentials）\nCredentialsProvider 凭据提供接口\nCredentialsStore 凭据存储接口\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/jenkins-plugin/ssh-slaves/",
        "title": "Jenkins SSH Agent",
        "tags": ["ssh", "plugin", "agent"],
        "description": "Jenkins SSH Agent",
        "content": "在 Jenkins 插件安装界面搜索 ssh-slaves。该方式会通过 ssh 协议来进行通信。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/plugin-dev/jenkins-plugin-dev-ui/",
        "title": "Jenkins UI",
        "tags": [],
        "description": "Jenkins UI 介绍",
        "content": "按钮 \u0026lt;j:jelly xmlns:f=\u0026#34;/lib/form\u0026#34;\u0026gt;\u0026lt;/j:jelly\u0026gt; \u0026lt;f:validateButton title=\u0026#34;Test Connection\u0026#34; method=\u0026#34;verifyConnect\u0026#34; with=\u0026#34;server,credentialsId\u0026#34; progress=\u0026#34;Testing...\u0026#34;\u0026gt;\u0026lt;/f:validateButton\u0026gt; \u0026lt;f:textbox/\u0026gt; \u0026lt;f:checkbox/\u0026gt; 下拉框 在 jelly 文件添加如下标签：\n\u0026lt;f:entry field=\u0026#34;method\u0026#34; title=\u0026#34;${%Method}\u0026#34;\u0026gt; \u0026lt;f:select/\u0026gt; \u0026lt;/f:entry\u0026gt; 在对应的后端类的 DescriptorImpl 中添加如下方法：\npublic ListBoxModel doFillMethodItems() { ListBoxModel listBoxModel = new ListBoxModel(); listBoxModel.add(HttpPost.METHOD_NAME); listBoxModel.add(HttpGet.METHOD_NAME); return listBoxModel; } 细心的童鞋肯定能看出来，doFillMethodItems 中间的 Method 就对应页面上的字段名称。\n校验 如果你的表单里有一个字段 crontab 希望能添加数据格式校验的话，可以在对应类的 DescriptorImpl 中添加方法来实现：\n\u0026lt;f:entry title=\u0026#34;${%Crontab}\u0026#34; field=\u0026#34;crontab\u0026#34;\u0026gt; \u0026lt;f:textbox/\u0026gt; \u0026lt;/f:entry\u0026gt; public FormValidation doCheckCrontab(@QueryParameter String value, @AncestorInPath Item item) { try { CronTabList ctl = CronTabList.create(fixNull(value), item != null ? Hash.from(item.getFullName()) : null); Collection\u0026lt;FormValidation\u0026gt; validations = new ArrayList\u0026lt;\u0026gt;(); updateValidationsForSanity(validations, ctl); updateValidationsForNextRun(validations, ctl); return FormValidation.aggregate(validations); } catch (ANTLRException e) { if (value.trim().indexOf(\u0026#39;\\n\u0026#39;)==-1 \u0026amp;\u0026amp; value.contains(\u0026#34;**\u0026#34;)) return FormValidation.error(Messages.TimerTrigger_MissingWhitespace()); return FormValidation.error(e.getMessage()); } } 凭据 \u0026lt;j:jelly xmlns:c=\u0026#34;/lib/credentials\u0026#34;\u0026gt; \u0026lt;c:select/\u0026gt; \u0026lt;/j:jelly\u0026gt; 高级 当有些字段具有默认值，通常情况下也无需修改时，你可以把这些字段隐藏起来（只有点击高级选项的时候才会展示）。\n\u0026lt;f:advanced\u0026gt; \u0026lt;f:entry field=\u0026#34;format\u0026#34; title=\u0026#34;Format\u0026#34;\u0026gt; \u0026lt;f:textbox/\u0026gt; \u0026lt;/f:entry\u0026gt; \u0026lt;/f:advanced\u0026gt; 静态资源文件 当我们需要在 Jenkins 插件中添加静态文件时，可以把静态访问放到 webapp 下。然后，通过类似下面的地址访问：\nhttp://localhost:8080/jenkins/plugin/sample-plugin-id/test.css\n帮助信息 如果想给你的页面添加帮助信息的话，可以参考这里。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins-x/",
        "title": "Jenkins X",
        "tags": [],
        "description": "Jenkins X",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins-x/jenkins-x/",
        "title": "Jenkins X",
        "tags": [],
        "description": "Jenkins X 特性介绍",
        "content": "添加 Gitee 为 Git 服务器\njx create git server gitea http://localhost:10080\nDevPod 目前只支持 overlay 类型的 Docker 驱动，通过命令 docker info | grep \u0026quot;Storage Driver\u0026quot; 查看 Docker 当前支持的类型。\n因此，我们需要的 Docker 版本为 v17.06。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/plugin-dev/jenkins-help/",
        "title": "Jenkins 帮助信息",
        "tags": [],
        "description": "Jenkins 帮助信息",
        "content": "正如大家看到的，在 Jenkins 的页面中，有很多地方能看到帮助信息。\n只要在某个页面文件（jelly）的同级目录下添加 help.html 后，就能在页面上看到关于该选项的帮助按钮。\n如果给某个字段添加帮助信息的话，也是类似的做法。例如：要对字段 password 添加帮助信息，就添加文件 help-password.html 即可。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/basic/jenkins-label/",
        "title": "Jenkins 标签",
        "tags": [],
        "description": "Jenkins 标签",
        "content": "master 是一个特殊的标签，即使任何一个节点上都没有填写该字符串，Jenkins 仍然会去调度 master 节点来运行。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/plugin-dev/jenkins-plugin-dev/",
        "title": "Jenkins 插件开发",
        "tags": [],
        "description": "Jenkins 插件开发教程",
        "content": "环境准备 你需要安装好Java和Maven。\n创建工程 执行命令 mvn --update-snapshots archetype:generate -Dfilter=io.jenkins.archetypes:，然后，根据提示选择骨架类型，以及当前 Maven 工程的信息。\n插件工程的父 POM 里定义了很多信息，包括：Jenkins 的版本、Java 版本、单元测试框架版本等。\n运行 在工程根目录下执行 mvn hpi:run\n访问 http://localhost:8080/jenkins/\nJenkins 版本选择 理论上，你可以任意选择一个喜欢的 Jenkins 版本来开发。但是，处于严谨的做法，同时也是 Jenkins 官方推荐的。你可以到 Jenkins 的下载页面找一个长期支持版本（LTS）。\n单元测试 Jenkins 官方提供了单元测试相关的内容。\n发布 mvn -Darguments=\u0026quot;-DskipTests\u0026quot; release:prepare\nmvn -Darguments=\u0026quot;-DskipTests\u0026quot; release:perform\n实验性版本发布 为了简化发布 beta 版本的插件到特定感兴趣的人群，Jenkins 有一个实验性的更新中心。它包括 alpha 和 beta 版本的插件，这些通常不会包含在常规的更新中心里。\n如果插件的版本中包含 alpha 或 beta 的插件，发布后就会出现在实验性的更新中心里，而不会出现在常规的更新中心。但是，实验性的更新中心也包含常规的版本发布。在所有的更新中心，较新的发布会隐藏掉较老的版本。例如：1.4版本会使得1.3-beta-2在实验中心里看不到。\n用户要使用实验性更新中心的话，只需要在插件管理-》高级的选项卡页面中，设置更新中心地址为 https://updates.jenkins.io/experimental/update-center.json。\n常规的更新中心地址为 https://updates.jenkins.io/update-center.json。\n参考 Extend Jenkins\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/plugin-dev/jenkins-plugin-extension/",
        "title": "Jenkins 插件扩展点",
        "tags": [],
        "description": "Jenkins 插件扩展点",
        "content": "接口 接口 hudson.ExtensionPoint 用于自动生成文档\n注解 注解 @hudson.Extension 加在实现类上，就可以获取扩展点的实现类列表。\nDemo Jenkins.getInstance().getExtensionList(ManagementLink.class).forEach(System.out::println); "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/basic/jenkins-host/",
        "title": "Jenkins 插件托管",
        "tags": [],
        "description": "本文介绍如何把一个 Jenkins 插件托管到 Jenkins 的 Github 上",
        "content": "如果你发现 Jenkins 官方的插件中无法满足你的需要，而且愿意把自己写的插件贡献给社区的话，可以参考下面的步骤。\n创建库 你需要在 GitHub 上申请一个账号，然后，把你的工程提交上去。\n提交请求 详细阅读托管要求\n在 Jira 上申请一个账号，然后创建一个 issues，等待管理员的审核。\n上传 首先，在 Jenkins 的成品库上，用上面 Jira 的账号登陆一次，保证该账号是可用的。\n你需要 Fork 上传权限申请，然后，根据要求编写对应的 YAML 文件。发起的 PR 通过以后，你就有了上传插件的权限了。\n发布 设置你的 Maven 账号，参考下面的配置修改 Maven 的配置文件~/.m2/settings.xml：\n\u0026lt;settings xmlns=\u0026#34;http://maven.apache.org/SETTINGS/1.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\u0026#34;\u0026gt; \u0026lt;servers\u0026gt; \u0026lt;server\u0026gt; \u0026lt;id\u0026gt;maven.jenkins-ci.org\u0026lt;/id\u0026gt; \u0026lt;!-- For parent 1.397 or newer; this ID is used for historical reasons and independent of the actual host name --\u0026gt; \u0026lt;username\u0026gt;...\u0026lt;/username\u0026gt; \u0026lt;password\u0026gt;...\u0026lt;/password\u0026gt; \u0026lt;/server\u0026gt; \u0026lt;/servers\u0026gt; \u0026lt;/settings\u0026gt; 等一切就绪，你的插件要发布时，只要执行 mvn release:prepare release:perform\n跳过测试 mvn -Darguments=\u0026quot;-DskipTests\u0026quot; release:prepare\n执行发布准备而且无需输入参数 mvn -Darguments=\u0026quot;-DskipTests\u0026quot; release:prepare -B\n如果上述的过程没有任何错误的话，大概两个小时左右，你就可以在插件官网中找到你的插件了。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/jenkins-plugin/localization-zh-cn/",
        "title": "Jenkins 简体中文插件",
        "tags": [],
        "description": "Jenkins 简体中文插件",
        "content": "Jenkins 的汉化（简体中文）需要安装中文插件。\n具体操作，打开 Jenkins 的插件管理界面，搜索中文后就能找到该插件。\n这里有一个视频可以供各位参考。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/jenkins-plugin/pipeline/",
        "title": "Jenkins 流水线插件",
        "tags": [],
        "description": "Jenkins 流水线插件",
        "content": "流水线是 Jenkins 的一大特点，而这点在 DevOps 中显得尤为重要。它可以把一系列过程串起来，并且很好地用图形化的方式展现出来。\n安装 在插件管理界面中搜索 workflow-aggregator 后，勾选点击安装。\n结构 /codes/jenkinsfile/simple.groovy pipeline { agent any stages{ stage(\u0026#34;one\u0026#34;) { steps{ echo \u0026#34;one\u0026#34; } } stage(\u0026#34;two\u0026#34;) { steps{ echo \u0026#34;two\u0026#34; } } } } 原文件 计算节点 Agent 阶段 Stage 后处理 Restful 接口 "
    },
    {
        "uri": "https://linuxsuren.github.io/translation/jenkins/",
        "title": "Jenkins 相关的翻译",
        "tags": [],
        "description": "Jenkins 相关的翻译",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/jenkins-plugin/simple-theme-plugin/",
        "title": "Jenkins 主题插件",
        "tags": [],
        "description": "Jenkins 主题插件",
        "content": "如果你想让你的 Jenkins 变得更加漂亮一些的话，这里有款 主题插件肯定能满足你的需求。\n从这里你能找到很多已经定制好的主题。先给出一个样例。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/jenkins-plugin/jira/",
        "title": "Jira",
        "tags": [],
        "description": "Jira 插件",
        "content": " Jira 插件 是 Jira 和 Jenkins 集成的一个插件。在系统配置中，添加 Jira 的配置后，如果在 git 提交日志中包含了 Jira ID 的话，就可以在构建的变更记录中直接点击进入到 Jira 对应到页面。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/java/jvm/",
        "title": "JVM",
        "tags": [],
        "description": "JVM",
        "content": "查看最大内存 执行命令 java -XX:+PrintFlagsFinal -version | grep HeapSize 或 java -XshowSettings:all\n切换 JAVA_HOME 如果需要在多个版本的 Java 之间切换的话，可以试试下面的命令（在 MacOS 下做的测试）：\nexport JAVA_HOME=`/usr/libexec/java_home -v 1.8` "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/build/jvm/",
        "title": "JVM Arguments",
        "tags": [],
        "description": "JVM Arguments",
        "content": "有些情况下，我们需要修改启动 Maven 时的 JVM 参数。\nMAVEN_OPTS=\u0026quot;-Xmx1024m\u0026quot; mvn clean 或 mvn -DjvmArgs=\u0026quot;-Xmx1024m\u0026quot; clean\n"
    },
    {
        "uri": "https://linuxsuren.github.io/tags/k8s/",
        "title": "k8s",
        "tags": [],
        "description": "",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/categories/k8s/",
        "title": "k8s",
        "tags": [],
        "description": "",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/k8s/k8s-landscape/",
        "title": "K8S landscape",
        "tags": [],
        "description": "K8S landscape",
        "content": " Name Description microk8s MicroK8s is a small, fast, single-package Kubernetes for developers, IoT and edge. "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/k8s/cert/",
        "title": "K8S 证书",
        "tags": [],
        "description": "K8S 证书",
        "content": "根证书公钥(ca.pem)与私钥(ca-key.pem)\nAPI Server 公钥和私钥\n集群管理员公钥和私钥\n从节点公钥和私钥\n根证书 openssl genrsa -out ca-key.pem 2048 openssl req -x509 -new -nodes -key ca-key.pem -days 10000 -out ca.pem -subj \u0026#34;/CN=kube-ca\u0026#34; API Server 证书 创建 openssl.cnf\n[req] req_extensions = v3_req distinguished_name = req_distinguished_name [req_distinguished_name] [ v3_req ] basicConstraints = CA:FALSE keyUsage = nonRepudiation, digitalSignature, keyEncipherment subjectAltName = @alt_names [alt_names] DNS.1 = kubernetes DNS.2 = kubernetes.default DNS.3 = kubernetes.default.svc DNS.4 = kubernetes.default.svc.cluster.local IP.1 = ${K8S_SERVICE_IP} IP.2 = ${MASTER_IPV4} openssl genrsa -out apiserver-key.pem 2048 openssl req -new -key apiserver-key.pem -out apiserver.csr -subj \u0026#34;/CN=kube-apiserver\u0026#34; -config openssl.cnf openssl x509 -req -in apiserver.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out apiserver.pem -days 365 -extensions v3_req -extfile openssl.cnf 一般生成的根证书(ca-key.pem, ca.pem)与 apiserver 证书(apiserver-key.pem,apiserver.pem)放置在 Master 节点的 /etc/kubernetes/ssl/ 路径下\nRef https://blog.csdn.net/shenshouer/article/details/53035948\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/k8s/kubectl/",
        "title": "Kubectl",
        "tags": [],
        "description": "Kubectl 的使用",
        "content": "查看集群信息 kubectl cluster-info\n下载 wget https://storage.googleapis.com/kubernetes-release/release/v1.10.0/bin/linux/amd64/kubectl\n切换上下文 kubectl config use-context dev\n查看上下文 kubectl config current-context\n导出用户证书 curl https://raw.githubusercontent.com/LinuxSuRen/getGo/master/k8s-create-user.sh | bash -s username Troubleshooting journalctl -u kubelet -f\nDelete pod kubectl get pods -a | grep Error | cut -d' ' -f 1 | xargs kubectl delete pod\n节点 查看节点列表 kubectl get node\n查看节点详情 kubectl get node -o wide\n显示标签 kubectl get node --show-labels=true\n添加标签 kubectl label node nodeName jenkinsAgent=maven\nPatch 在调试的时候，我们可能需要反复地修改 k8s 资源中的某几个字段。如果，每次都使用 kubectl edit 命令操作的话，会比较麻烦。通过 kubectl 的子命令 patch 可以实现快速地实现这个过程。\n该命令，可以通过 json 或者 yaml 格式来对资源打补丁。下面，给出一个使用 json 的例子：\nkubectl patch deploy template -n namespace --patch '{\u0026quot;status\u0026quot;:{\u0026quot;phase\u0026quot;:\u0026quot;Pending\u0026quot;}}'\n更新镜像 kubectl set image deploy/your-deployment -n namespace imageName=surenpi/image\n"
    },
    {
        "uri": "https://linuxsuren.github.io/categories/kubernetes/",
        "title": "kubernetes",
        "tags": [],
        "description": "",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/service/",
        "title": "Linux Service",
        "tags": [],
        "description": "Linux Service",
        "content": "#!/bin/sh ### BEGIN INIT INFO # Provides: suren # Required-Start: $network $remote_fs $syslog # Required-Stop: $network $remote_fs $syslog # Should-Start: jenkins # Should-Stop: jenkins # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 # Short-Description: http://surenpi.com # Description: http://surenpi.com ### END INIT INFO case $1 in start) echo \u0026#34;start\u0026#34; nohup java -jar /var/www/jenkins/jenkins.war --httpPort=9099 \u0026gt; /var/www/jenkins/jenkins.log 2\u0026gt; /var/www/ jenkins/jenkins-error.log \u0026amp; ;; stop) echo \u0026#34;stop\u0026#34; ;; *) echo \u0026#34;Usage: $0 (start|stop)\u0026#34; ;; esac "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/mac/lsof/",
        "title": "lsof",
        "tags": [],
        "description": "lsof",
        "content": "查看端口占用 lsof -nP -i4TCP:9091\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/mac/",
        "title": "Mac",
        "tags": [],
        "description": "Mac 操作系统",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/mac/mac/",
        "title": "Mac 快捷键",
        "tags": [],
        "description": "Mac 快捷键",
        "content": "按键符号 ⌘(command)\n⌥(option)\n⇧(shift)\n⇪(caps lock)\n⌃(control)\n↩(return)\n⌅(enter)\n快捷键 删除文件 command + delete\n浏览器 关闭选项卡 command + w\n前后切换选项卡 command + \u0026lt;-\n指定顺序切换选项卡 command + 1\n关闭浏览器 command + q\n截图 截取全屏并保存文件 shift + command + 3\n截取部分并保存文件 shift + command + 4\n截取全屏并保存粘贴板 shift + control + command + 3\n截取部分并保存粘贴板 shift + control + command + 4\n丢失管理身份 当你的误操作导致丢失了 mac 用户的管理员身份时，可以按照下面的步骤找回管理。\n开机后按下 command+s\n进入终端后输入命令 `/sbin/mount -uaw``\n执行命令 rm /var/db/.applesetupdone\n操作系统重启后，会提示用户重新创建一个管理员身份。注意，这不会删除之前的用户信息。登陆系统后，你可以用户管理功能再次把之前的用户身份找回来。\n翻盖开机 取消命令：sudo nvram AutoBoot=%00\n启用命令：sudo nvram AutoBoot=%03\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/build/maven-repository/",
        "title": "Maven Repository",
        "tags": [],
        "description": "Maven 仓库",
        "content": "Maven 仓库（Repository）大致可以分为私有、公有两类。我们暂且认为企业内部的就是私有的，但是，公有的仓库也会有很多（除 Maven 官方的中央仓库以外）。\n当我们的 Maven 项目发布到特定仓库以后，可以在需要依赖的 pom.xml 文件中添加明确的仓库地址，这样就可以避免在构建构成中因为找不到而报错了。下面给出一个参考配置：\n\u0026lt;project\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;repo.jenkins-ci.org\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://repo.jenkins-ci.org/public/\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;nexus-oss-snapshots\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;https://oss.sonatype.org/content/repositories/snapshots/\u0026lt;/url\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;releases\u0026gt; \u0026lt;enabled\u0026gt;false\u0026lt;/enabled\u0026gt; \u0026lt;/releases\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;release\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;https://oss.sonatype.org/content/repositories/releases\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;/project\u0026gt; 注意 central 这个 id 是 Maven 官方中央仓库的默认值，如果你设置的仓库使用了该值的话就会覆盖中央仓库。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/build/maven-gpg-plugin/",
        "title": "maven-gpg-plugin",
        "tags": [],
        "description": "maven-gpg-plugin",
        "content": "[INFO] \u0026mdash; maven-gpg-plugin:1.5:sign (sign-artifacts) @ kubernetes-model-generator \u0026mdash; gpg: directory \u0026lsquo;/home/jenkins/.gnupg\u0026rsquo; created gpg: keybox \u0026lsquo;/home/jenkins/.gnupg/pubring.kbx\u0026rsquo; created gpg: no default secret key: No secret key gpg: signing failed: No secret key\ngpg: signing failed: Inappropriate ioctl for device\nhttps://github.com/pstadler/keybase-gpg-github/issues/11 https://github.com/jenkinsci/remoting/pull/280 https://gist.github.com/michaelajr/ff4693bce9fc20e5200b34683aa4ba51\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/k8s/minikube/",
        "title": "Minikube",
        "tags": [],
        "description": "Minikue 安装",
        "content": "下载 wget https://github.com/kubernetes/minikube/releases/download/v0.26.1/minikube-linux-amd64\n然后，添加可执行权限并移动到执行目录下：\nchmodd u+x minikube-linux-amd64 \u0026amp;\u0026amp; mv minikube-linux-amd64 /usr/local/bin/minikue\n下载ISO wget https://storage.googleapis.com/minikube/iso/minikube-v0.26.0.iso\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/mkfifo/",
        "title": "mkfifo",
        "tags": [],
        "description": "make fifos",
        "content": "nc -lkv localhost 9090 -c \u0026rsquo;tee /dev/stderr | nc -v baidu.com 80 | tee /dev/stderr'\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/banana-pi/monitor/",
        "title": "Monitor",
        "tags": [],
        "description": "Monitor",
        "content": "查看温度 安装软件 apt-get install sensord\n然后执行命令 sensors\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/mplayer/",
        "title": "MPlayer",
        "tags": [],
        "description": "MPlayer",
        "content": "音频 只播放音频 mplayer -vo sample.mp4\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/nc/",
        "title": "nc",
        "tags": [],
        "description": "arbitrary TCP and UDP connections and listens",
        "content": "简单服务器 nc -l localhost 8080 我们可以利用这个来观察接收到的 HTTP 请求\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/build/nexus/",
        "title": "Nexus",
        "tags": [],
        "description": "Nexus",
        "content": "初始密码 Nexus3 的 admin 的初始密码默认会自动生成，并保存在文件 /nexus-data/admin.password 中。\n为了自动化 Nexus 的安装和初始化配置工作，我们需要能够将管理员的初始密码固定或者可以设置。 这时候，你可以通过下面的两个途径来做到：\n修改 $data-dir/etc/nexus.properties 文件中的值 nexus.security.randompassword 为 false 设置环境变量 NEXUS_SECURITY_RANDOMPASSWORD 的值为 false See Also\nSonatype community discuss\nSource code\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/server/nginx/",
        "title": "Nginx",
        "tags": [],
        "description": "Nginx",
        "content": "Nginx 配置文件的一大特点是：必须要以分号结尾。\n变量 Name Description $scheme The scheme of HTTP request, could be http, https $host $request_uri ] 逻辑判断 ngx_http_rewrite_module rewrite server { listen 80; server_name surenpi.com; location / { rewrite ^ https://linuxsuren.github.io/blog/; } } return Syntax: return code [text]; return code URL; return URL; Default: - Context: server, location, if if ($host = \u0026#34;github.com\u0026#34;) { return 301 https://nexus-b.alauda.cn/repository/github-proxy$request_uri; } HTTPS "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/mac/open/",
        "title": "open",
        "tags": [],
        "description": "open",
        "content": "open http://surenpi.com 打开浏览器\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/java/openj9/",
        "title": "OpenJ9",
        "tags": [],
        "description": "OpenJ9",
        "content": "下载 点击这里这里可以找到 Java8 的下载链接。\n参考 openj9-docs\nopenj9-ci\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/ubuntu/packing/",
        "title": "Packing",
        "tags": [],
        "description": "Packing",
        "content": "http://packaging.ubuntu.com/html/getting-set-up.html\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/mac/pbcopy/",
        "title": "pbcopy",
        "tags": [],
        "description": "Copy from mac command line",
        "content": "cat test.log | pbcopy 通过命令行拷贝\npbpaste 通过命令粘贴\n"
    },
    {
        "uri": "https://linuxsuren.github.io/tags/pipeline/",
        "title": "Pipeline",
        "tags": [],
        "description": "",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/tags/plugin/",
        "title": "plugin",
        "tags": [],
        "description": "",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/database/postgres/",
        "title": "Postgres",
        "tags": [],
        "description": "Postgres",
        "content": "安装 helm install --namespace default stable/postgresql --name postgre\ndocker run -p 5432:5432 -u root --name some-postgres -e POSTGRES_PASSWORD=mysecretpassword -d postgres\n获取密码 export POSTGRES_PASSWORD=$(kubectl get secret postgre-postgresql -o jsonpath=\u0026quot;{.data.postgresql-password}\u0026quot; | base64 --decode)\n连接数据库 kubectl run postgre-postgresql-client --rm --tty -i --restart='Never' --image docker.io/bitnami/postgresql:11.3.0 --env=\u0026quot;PGPASSWORD=$POSTGRES_PASSWORD\u0026quot; --command -- psql --host postgre-postgresql -U postgres\n查询 创建数据库 CREATE DATABASE testdb;\n查询数据库 \\l\n查询当前数据库中的表 dt\n选择数据库 \\c postgres;\n备份和恢复 pg_dump -U [postgres-user] [database-name] \u0026gt; database.sql\ncat database.sql | psql -U [postgres-user] -d [database-name]\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/test/postman/",
        "title": "Postman",
        "tags": [],
        "description": "Postman",
        "content": "利用 Postman 可以很方便地基于 HTTP 的 API 做接口测试。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/python/",
        "title": "Python",
        "tags": [],
        "description": "",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/packagemanager/rpm/",
        "title": "RPM",
        "tags": [],
        "description": "RPM",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/categories/scm/",
        "title": "scm",
        "tags": [],
        "description": "",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/sed/",
        "title": "sed",
        "tags": [],
        "description": "sed",
        "content": "cat .m2/settings.xml | sed s/[[:space:]]//g 清除空白字符\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/shell/",
        "title": "Shell",
        "tags": [],
        "description": "Linux Shell 的基本介绍",
        "content": "执行最近的命令 有几种方法可以快速地执行最近执行过的命令：\n!! 或者 !-1 执行上一个命令 !u 执行上一个以 u 开头的命令 Ctrl+R 搜索命令 Ctrl+P Ctrl+O 下载并执行 curl http://test.com/test.sh | bash -s arg1 arg2\n文件路径 从文件路径中提取文件名和目录\npath=/var/www/1.log echo $(basename $path) echo $(dirname $path) 文件是否存在 if [ ! -f \u0026#34;env.sh\u0026#34; ]; then echo \u0026#34;we need the env.sh to setup vars\u0026#34; exit -1 else echo \u0026#34;file exists\u0026#34; fi if [ ! -d \u0026#34;env.sh\u0026#34; ]; then echo \u0026#34;we need the env.sh to setup vars\u0026#34; exit -1 else echo \u0026#34;file exists\u0026#34; fi 脚本相关 ${BASH_SOURCE[0]} 脚本所在的相对路径\n$(dirname \u0026quot;${BASH_SOURCE[0]}\u0026quot;) 脚本所在的相对目录\n参数 Shell 脚本可以像其他的命令行一样接收参数\n变量名称 解释 $1 第一个参数 $2 第二个参数 $@ 完整的参数列表 $# 参数个数 逻辑判断 if [[ \u0026#34;1\u0026#34; == \u0026#34;1\u0026#34; \u0026amp;\u0026amp; \u0026#34;2\u0026#34; == \u0026#34;2\u0026#34; ]]; then echo \u0026#34;equal\u0026#34; fi 循环 获取当前目录下的文件并循环打印出文件名：\nfor f in `ls`; do echo $f done 函数 我们可以在 shell 脚本中用下面的方式来定义函数：\nfunction_name(){ echo \u0026#34;hello\u0026#34; } function_name "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/shell-example/",
        "title": "Shell Example",
        "tags": [],
        "description": "Shell Example",
        "content": "输出文件制定行 Solution 1\nnum=0 head -n 10 file.txt | while read line; do if [ \u0026#34;$num\u0026#34; == \u0026#34;9\u0026#34; ]; then echo $line; break; fi; num=$((num+1)); done Solution 2\nawk \u0026#39;NR==10\u0026#39; file.txt "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/codequality/sonarqube/",
        "title": "Sonarqube",
        "tags": [],
        "description": "Sonarqube",
        "content": "Docker docker run --restart=always -d --name sonarqube -p 9000:9000 -p 9092:9092 sonarqube Helm 我们可以通过 helm chart 来快速地安装一个 Sonarqube。下面的例子中，我们使用 postgresql 作为数据库：\nhelm install --name postgresql --set postgresqlUsername=sonarUser \\ --set postgresqlPassword=sonarPass,postgresqlDatabase=sonarDB \\ --set persistence.enabled=false \\ --set service.type=NodePort \\ stable/postgresql 安装 Sonarqube：\nhelm install --name sonaqube \\ --set postgresql.postgresServer=10.111.207.76 \\ --set postgresql.service.port=30180 \\ --set service.type=NodePort \\ stable/sonarqube 默认的用户名和密码都是：admin\n安装插件 http://129.28.186.10:30870/admin/marketplace\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/java/spacevim/",
        "title": "SpaceVim",
        "tags": [],
        "description": "SpaceVim",
        "content": "Reference Use Vim as a Java IDE\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/split/",
        "title": "split",
        "tags": [],
        "description": "split",
        "content": "切割文件 指定每个文件的大小和名称前缀 split -b 10m minikube-v0.26.0.iso minikube-v0.26.0.iso-part-\n合并文件，可以使用命令 cat minikube-v0.26.0.iso-part-* \u0026gt; minikube.iso\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/sshd/",
        "title": "SSDH",
        "tags": [],
        "description": "SSHD",
        "content": "禁止root用户远程登录 修改sshd配置文件 /etc/ssh/sshd_config\nPermitRootLogin no\n然后重启服务 service ssh restart\n"
    },
    {
        "uri": "https://linuxsuren.github.io/tags/ssh/",
        "title": "ssh",
        "tags": [],
        "description": "",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/ssh/",
        "title": "SSH",
        "tags": [],
        "description": "SSH",
        "content": "配置文件 vim /etc/ssh/sshd_config\n允许 Root 登陆 如果你希望允许 root 用户可以通过 ssh 远程登陆的话，可以找到配置文件，并将 PermitRootLogin 设置为 yes。\n无密码登录 在客户端执行命令ssh-keygen生成id_rsa（私钥）、id_rsa_pub（公钥）\n在服务器端~/.ssh/authorized_keys文件中添加id_rsa.pub的内容\n或者，在需要无密码登录的机器上执行：ssh-copy-id user@ip\n证书登陆 ssh -i test.pem root@localhost\n服务重启 service ssh restart\n密码传递 我们可以通过 sshpass 给 ssh 传递密码，下面给出一个例子：\nsshpass -p password ssh root@192.168.1.1\n通过 brew 安装的话，可以执行下面的命令：\nbrew install https://raw.githubusercontent.com/kadwanev/bigboybrew/master/Library/Formula/sshpass.rb\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/golang/go-sync/",
        "title": "Sync",
        "tags": [],
        "description": "Sync",
        "content": "package main import ( \u0026#34;sync\u0026#34; ) type Boot struct { count int once sync.Once } func (b *Boot) Init() { b.once.Do(func() { b.count += 1 }) } func main() { b := Boot{ count: 0, } b.Init() } "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/golang/syntax/",
        "title": "Syntax",
        "tags": [],
        "description": "Syntax",
        "content": "集合 判断 Map 中是否存在指定 Key\npackage main import \u0026#34;fmt\u0026#34; func main() { mapTest := map[string]string{ \u0026#34;hao\u0026#34;: \u0026#34;hao value\u0026#34;, } if _, ok := mapTest[\u0026#34;hao\u0026#34;]; ok { fmt.Println(\u0026#34;ok\u0026#34;) } } "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/browser/chrome/",
        "title": "Talk something about Chrome",
        "tags": [],
        "description": "Talk something about Chrome",
        "content": "When you cannot visit a website with HTTPS, please click the blank place then type the following text:\nthisisunsafe\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/tcpdump/",
        "title": "tcpdump",
        "tags": [],
        "description": "dump traffic on a network",
        "content": "tcpdump -i lo0 -s0 -v port 8080\ntcpdump dst jenkins-zh.gitee.io -s0 -v\ntcpdump src localhost\ntcpdump -o lo0 -s0 -v port 8080\nsudo tcpflow -p -i lo0 -c port 8080\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/team/team-building/",
        "title": "Team Building",
        "tags": [],
        "description": "团队建设",
        "content": "做很多事情，都是需要一个团队的。我主要介绍的是如何才能打造一个有自己文化的越来越好的软件研发团队。这里涉及到了三个问题：为什么需要打造、什么是团队文化、好团队的标准。\n打造 首先，我不认为花钱把一堆人招聘过来，然后每天拼命地加班干活，就算是一个团队了。尤其对于新组建，或者是队伍中新加入的成员比较多的情况，“团队建设”就是一件非常重要的事情。对，我认为团队是“建设”起来的，而不是“买”来，更加不是通过“伞兵空降”来的。而建设这个词，大家应该多少有点认识吧，绝非是一朝一夕来的——即使是3D打印技术也是要一个一个部件来打印的。\n一把好剑，是打铁匠一锤一锤地用心打造出来的。这样的剑，锋利无比；这样的剑，能在关键时刻发挥应有的作用；这样的剑，是受众人的肯定的。一个好的团队，同样是需要Leader带领每个成员一同打造的。这样的团队中，每个成员之间都不仅仅是工作和任务的关系；这样的团队中，每个成员都是有其重要的位置；这样的团队中，每个成员都尽可能快乐地得到成长；这样的团队中，每个成员都是在积极主动地向前奔跑；这样的团队中，自己的文化不会丢失。\n每个年轻的团队，都会有很多值得改进和提升的地方。而什么的团队，是我这里说的“年轻”的团队呢？某个公司成立十年，而某个项目组又是从一开始就存在的；这样的团队就一定不是年轻的团队吗？我这里的“年轻”更加强调的是——幼稚、没有形成自己的做事风格。每个团队，都会有人员的变动；如果变动的过于频繁，也是“年轻”的一个体现。这里简单地引入一个思考：如果一个新加入的成员，效率或者态度让人有点不满意，那我们该怎么办，直接抛弃呢还是任其发展呢？\n文化 什么是文化呢？这个问题很难回答，只能是谈一点自己的认识。有自己文化的团队，并不需要依靠公司制度、强制加班等等生硬的东西来改造成员。文化应该是能够在团队中每个人的一言一行中传播的，是熏陶出来，不是加工好的。\n强迫大家每天加班到很晚是一个件非常自私的事情（排除公司制度要求的情况），这完全是Leader害怕完成不了项目而出的下下策。在绝大多数情况下，必须通过加班才能搞定的事情，其实不加班也能搞定。那么，你有没有反复地思考这个问题呢？怎么样才能不加班就把“活儿”干完呢？\n如何才能做到团队成员之间沟通交流都比较Open，想要说、敢说、会说意见或者建议。这是Leader每天都应该思考的问题。没有了平等、积极的沟通，团队就是一潭死水。\n标准 每时每刻，每人都应该在积极主动地思考：如何才能进一步提高工作效率（我这里的效率，当然是建立在高质量的基础上）。这是我所认为的好团队，这样的团队不是只会搞定上面分配的任务，而会有团队内部的沉淀，是有自己文化的团队。\n对团队成员整体研发素质的提高，减少木桶效应带来的问题。是Leader或者团队中的技术达人所值得思考的问题。自己能够在不断地成长，很简单；能带领整个团队一起成长才是件有挑战的事情。\n让大家的基础技术能力、意识保持在一个比较均衡的状态。\n利用一个工具来来做到能对团队成员的技能分布有个清晰的认识。人类之所以伟大的一个特点，就在于学会了使用工具。工欲善其事必先利其器，没有一整套高效率的工具的支撑，那么你的团队还处在并将长期处在原始阶段。\n测试人员 测试人员不能仅仅停留在手工测试，看功能能不能完成、有没有页面上的错误提示等。\n程序或者系统、工具，开发完成后，都是要实施的，仅仅把功能测试完成并不算结束。在实施和运维的阶段，也可能会出现很多问题。所以，我的想法是要让测试人员提前介入到这些阶段。\n测试还要对系统的部署过程进行测试。例如：要学会安装程序、数据库使用、服务的启动和停止等。\n系统运行起来后，最好要查看日志文件中是否有不应该出现的异常、报错，浏览器控制台是否有错误信息，是否有无法加载的js、css、image等资源。\n开发人员 很多开发人员，只知道Coding，对Web应用部署、Jenkins持续构建工具、Linux操作系统等都不了解。这是非常不应该的——如果连自己写的系统或者程序都不会部署，怎么能说的过去呢。\n资产沉淀 对一个团队来说，一定会有很多资产需要持续地积累、沉淀，包括：制度、开发规范、项目文档、技术资料等等。那么用什么形式来维护比较好呢，word是我不推荐的一种方式。\n我维护过的一些帮助文档，有一些是非常大的，可能会有几十甚至上百页，每次修改都是很痛苦的。除了它的笨重以外，还有很多致命的缺点：无法多人协作、难以进行版本维护、难以检索。经验证明，难用的文档就约等于没有。wiki这种web的形式就是非常好的，还可以生成多种格式的文档。\n分享 在团队中，每个人的具体职责不同，所专长的领域也不同。我们应该逐渐建立起来成员之间热衷于分享的精神。\n对于开发人员来说，每当解决一个较大模块的问题时，就可以给其他人做个分享。第一，可以检验自己对这个问题理解的是否够清楚明白；第二，其他人再次遇到这类问题时，就可以减少不必要的重复劳动，当然会提高效率。\n更多有关分享的介绍，请参考《Java开发成长之路第七年》。\nLeader 当前，很多人称带团队的人之为“领导”，亦或者是“老大”。前者有“官僚”之嫌，后则有“专政”之嫌，最后很容易给人这样一种感觉——我们这些底层coding的人就是个“干活儿”的。\n项目是大家的，每个人都应该有主人翁意识。这样的话，我经常听到，但都是在“打江山”尽义务的时候；到享受权利的时候就体现不到了。如果是“一家人”，就不应该有隐瞒、有秘密，不应该有“小九九”。如果你正处于“领导”的位置上，而又做不到我刚说的那一点的话，就别说什么“一家人”。\n如果我是项目的负责人（一家三口人的话，每个人都应该是这个家的负责人，荣辱与共），项目就是我的孩子，无条件地想要做对“孩子”好的事情。\n上面都是废话，我之所以用“Leader”而不是“领导”，只是为了说明一点——团队需要的是带头人，而不是专政的“君主”。一切都应当是民主的，而身为“带头人”是应该时时刻刻考虑“家里人”的健康成长。为了团队中的每位争取奖金，考虑每个人是否都有了应有的成长。\n知识体系 只有成体系了，才能发挥更大的作用。\n只有成体系了，才能发现自己的不足和漏洞。\n我建议，把自己所涉及过的内容，都归纳到一棵树上。这棵树，要有树枝树叶，要有树根。\n要是有了这棵树以后，就可以有计划地来丰富自己的知识体系了。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/telnet/",
        "title": "telnet",
        "tags": [],
        "description": "telnet",
        "content": "退出 首先，按下 Ctrl+] 然后输入 \\q 后，按下回车即可退出 Telnet。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/golang/template/",
        "title": "Template",
        "tags": [],
        "description": "Go Template",
        "content": "Action 1.条件语句 2.迭代 3.封装 4.引用\n条件语句 {{ if arg }} code {{ end }} {{ if arg }} code-1 {{ else }} code-2 {{ end }} 迭代 {{ range . }} {{ end }} {{ range $key, $value := . }} {{ $key }} {{ $value }} {{ end }} 数组 {{ index \u0026#34;abc\u0026#34; 0 }} "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/golang/testing/",
        "title": "Testing",
        "tags": [],
        "description": "Testing",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/tr/",
        "title": "TR",
        "tags": [],
        "description": "TR",
        "content": "cat .m2/settings.xml | tr -s [:blank:] 清除空白字符\necho abc | tr a-z A-Z 大小写转换\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/typescript/",
        "title": "TypeScript",
        "tags": [],
        "description": "TypeScript",
        "content": "TypeScript\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/typescript/typescript/",
        "title": "TypeScript",
        "tags": [],
        "description": "TypeScript",
        "content": "Error: Cannot find module '../lib/utils/unsupported.js'\n当遇到上面的错误时，可以试试下面的办法：\nsudo rm -rf /usr/local/lib/node_modules/npm brew reinstall node "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/document/typora/",
        "title": "Typora",
        "tags": [],
        "description": "",
        "content": "Typora 支持用 Markdown 的方式来“画”流程图。\n流程图 graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] 序列图 sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts prevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! 甘特图 gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d 参考 https://support.typora.io/Draw-Diagrams-With-Markdown/\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/mac/u-creator/",
        "title": "U Creator",
        "tags": [],
        "description": "U Creator",
        "content": "$ diskutil list #查看当前分区情况，记住你的U盘的名称 $ diskutil unmountDisk /dev/disk1 #卸载U盘。这里的disk1是刚刚显示的名称 $ dd if={iso_dir} of=/dev/disk1 bs=1m #进行拷贝 diskutil list #1.找到U盘的代号 比如disk1 diskutil unmountDisk /dev/disk1 #2. diskutil eraseDisk JHFS+ iDisk disk1 #3. brew install e2fsprogs diskutil unmountdisk /dev/disk2s1 sudo $(brew --prefix e2fsprogs)/sbin/mkfs.ext3 /dev/disk2s1 "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/ubuntu/",
        "title": "Ubuntu",
        "tags": [],
        "description": "Ubuntu",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/user/",
        "title": "user",
        "tags": [],
        "description": "user",
        "content": "添加用户 useradd user-name 添加用户 user-name ，并没有添加用户目录、密码、shell等\nuseradd user-name --home /home/user-name --create-home\nsu user-name\nuserdel user-name\nsudo xx is not in the sudoers file.\n这时候可以使用 root 账号修改配置文件来解决：vim /etc/sudoers\n或者把用户加到用户组 sudo 中。 usermod -a -G sudo jenkins\n设置用户 usermod --shell /bin/bash user-name\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/golang/vendor/",
        "title": "Vendor",
        "tags": [],
        "description": "Golang 包依赖",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/editor/vim/core/vim/",
        "title": "Vim",
        "tags": [],
        "description": "Vim",
        "content": "粘贴缩进错乱 让 vim 进入 paste 模式，命令如下：\n:set paste\n解除 paste 模式的命令如下：\n:set nopaste\n字符 :set invlist 显示不可见字符\n:set nolist 隐藏不可见字符\n样例配置 set number set incsearch set hlsearch set autoindent \u0026#34;set smartindent set autochdir set ignorecase \u0026#34;set textwidth=80 set colorcolumn=+1 set tabstop=4 set shiftwidth=4 set expandtab \u0026#39;把tab转为空格 set backspace=indent,start,eol set showmatch set matchtime=1 set ruler set foldmethod=syntax \u0026#34;set foldmethod=indent set foldlevel=0 set encoding=utf-8 set termencoding=utf-8 set langmenu=zh_CN.utf-8 language message zh_CN.utf-8 \u0026#34;set titlestring=中文 set nolist set nocursorline set nocursorcolumn syntax on filetype on "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/editor/vim/",
        "title": "VIM",
        "tags": [],
        "description": "VIM",
        "content": "编辑器\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/editor/vim/core/vim-buffer/",
        "title": "VIM Buffer",
        "tags": [],
        "description": "VIM Buffer",
        "content": ":ls 或 :buffers 列出所有的缓冲区\n:b 1 切换到指定编号的缓冲区\n:sb 1 或 :sbuffer 1 使用缓冲区新建切分窗口\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/editor/vim/plugins/vim-bundle/",
        "title": "VIM bundle",
        "tags": [],
        "description": "VIM bundle",
        "content": "git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim\nReference Vundle\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/editor/vim/core/vim-cmd/",
        "title": "VIM Command",
        "tags": [],
        "description": "VIM Command",
        "content": "命令模式 删除文本 x 删除当前字符 X 删除前一个字符\ndd 删除当前行 D 删除当前字符后的文本\ndw 删除当前单词\n字符替换 R 开启字符串替换模式，知道按下 ESC\nr 替换当前字符\n转换为大写 通过命令 v 选中文本，然后用 U 变成大写，用 u 变为小写。\n通过命令 ~ 可以切换所选或光标所在的字符大小写\ng~~ 切换当前行的大小写\nguu 切换当前行为小写\ngUU 切换当前行为大写\n撤销 u 撤销一次更改 ctrl+r 恢复一次撤销\n剪贴板 :reg 或 :register 或 :dis 或 :display 显示剪贴板\nyy 拷贝当前行\np 粘贴\n格式化 :left 居左对齐 :right 居右对齐\n数字 ctrl+a 数字+1\nctrl+x 数字-1\n其他 ctrl+g 显示当前文件路径\n编辑模式 Reference Vim documentation: help Vim documentation: change\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/editor/vim/core/",
        "title": "VIM core",
        "tags": [],
        "description": "VIM core",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/editor/vim/plugins/vim-go/",
        "title": "VIM GoLang",
        "tags": [],
        "description": "VIM plugin for GoLang",
        "content": "Dependency go get -v github.com/zmb3/gogetdoc go get -v golang.org/x/tools/cmd/guru1 go get -v github.com/golang/lint/golint go get -v github.com/davidrjenni/reftools/cmd/fillstruct\nAction :GoRun :GoBuild :GoTest :GoDef :GoRename Reference vim-go vim-go-tutorial\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/editor/vim/core/vim-network/",
        "title": "VIM Network",
        "tags": [],
        "description": "Reading and writing files over a network",
        "content": "VIM 支持直接编辑网络上的文件。例如：vim https://linuxsuren.github.io/blog/\nReference http://vimdoc.sourceforge.net/htmldoc/pi_netrw.html\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/editor/vim/plugins/",
        "title": "VIM Plugins",
        "tags": [],
        "description": "Here are lots of plugins for VIM",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/editor/vim/core/vim-regex/",
        "title": "VIM Replace",
        "tags": [],
        "description": "VIM Replace",
        "content": "简单文本替换 :[range]s[ubtitute]/{pattern}/{string}/[flags] [count]\n全局文本替换 :[range]g[lobal]/{pattern}/[cmd]\n:[range]g[lobal]!/{pattern}/[cmd]\n示例：\n将找到的第一个字符串abc替换为def s/abc/def\n将找到的所有字符串abc替换为def s/abc/def/g\n将包含有字符串abc的行删除 g/abc/ del\n将行首增加序列号 let i = 1 | g/./s/^/\\=i/ | let i += 1\n将所有包含image331的行中，替换331为从331开始递增的数字 let i = 331 | g/image331/s/331/\\=i/ | let i += 1\n从1358行开始进行替换 let i = 792 | 1358,$g/resources\\/image/s/\\d\\d\\d/\\=i/ | let i += 2\n将所有已开头的行在结尾添加 g/^\\s*\u0026lt;para\u0026gt;/ s/$/\u0026lt;\\/para\u0026gt;\n把以开头，若干个空白结尾的行删除 g/^\\s*\u0026lt;para\u0026gt;\\s*\u0026lt;\\/para\u0026gt;$/ del\n把以空白字符开头，并且第一个字符不是\u0026lt;的行首添加 g!/^\\s*\u0026lt;/ s/^/\u0026lt;para\u0026gt;\n把中间还有尖括号(\u0026lt;\u0026gt;)的行删除 g/\u0026lt;para\u0026gt;.*[\u0026lt;\u0026gt;].*\u0026lt;\\/para\u0026gt;/ del\n找到没有以结尾的行 s/para\u0026gt;.*[^(\u0026lt;\\/para\u0026gt;)]$\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/editor/vim/core/vim-tab/",
        "title": "VIM tab",
        "tags": [],
        "description": "VIM 中使用选项卡",
        "content": ":tabnew a.log 新建选项卡\n:tabNext 切换到下一个选项卡\n:tabprevious 切换到上一个选项卡\n:tabclose 关闭选项卡\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/editor/vim/plugins/vim-airline/",
        "title": "vim-airline",
        "tags": [],
        "description": "vim-airline",
        "content": "Reference vim-airline\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/editor/vim/plugins/vim-fugitive/",
        "title": "Vim-Fugitive",
        "tags": [],
        "description": "Vim-Fugitive",
        "content": "Installation git clone https://github.com/tpope/vim-fugitive.git ~/.vim/bundle\nUsage :Gstatus 查看变更状态，等同于 git status\n:Gcommit % 提交代码，等同于 git commit\n:Gpush 推送代码\n:Gpush -u origin test 推送新的分支\n:Gpull 拉取代码\nReference vim-fugitive vim-scripts\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/editor/vscode/",
        "title": "vscode",
        "tags": [],
        "description": "vscode",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/wget/",
        "title": "wget",
        "tags": [],
        "description": "wget",
        "content": "代理 通过命令参数设置代理 wget https://google.com -e \u0026quot;https_proxy=http://localhost:1234\u0026quot;\n为了方便使用，我们可以为 wget 添加一个别名，如下所示：\nalias wall-wget='wget -e \u0026quot;https_proxy=http://localhost:8123\u0026quot; '\n递归下载 wget -A .hpi -np -r http://mirrors.jenkins-ci.org/plugins/hugo/ 参数 -A 指定要下载的文件扩展名 -np 不递归父目录 -r 表示递归下载\nHSTS wget http://github.com/jenkins-zh/jenkins-cli/releases/latest/download/jcli-darwin-amd64.tar.gz --no-hsts\n选项分类列表 启动 -V, –version 显示wget的版本后退出 -h, –help 打印语法帮助 -b, –background 启动后转入后台执行 -e, –execute=COMMAND 执行`.wgetrc\u0026rsquo;格式的命令，wgetrc格式参见/etc/wgetrc或~/.wgetrc\n记录和输入文件 -o, –output-file=FILE 把记录写到FILE文件中 -a, –append-output=FILE 把记录追加到FILE文件中 -d, –debug 打印调试输出 -q, –quiet 安静模式(没有输出) -v, –verbose 冗长模式(这是缺省设置) -nv, –non-verbose 关掉冗长模式，但不是安静模式 -i, –input-file=FILE 下载在FILE文件中出现的URLs -F, –force-html 把输入文件当作HTML格式文件对待 -B, –base=URL 将URL作为在-F -i参数指定的文件中出现的相对链接的前缀 –sslcertfile=FILE 可选客户端证书 –sslcertkey=KEYFILE 可选客户端证书的KEYFILE –egd-file=FILE 指定EGD socket的文件名\n下载 –bind-address=ADDRESS 指定本地使用地址(主机名或IP，当本地有多个IP或名字时使用) -t, –tries=NUMBER 设定最大尝试链接次数(0 表示无限制). -O –output-document=FILE 把文档写到FILE文件中 -nc, –no-clobber 不要覆盖存在的文件或使用.#前缀 -c, –continue 接着下载没下载完的文件 –progress=TYPE 设定进程条标记 -N, –timestamping 不要重新下载文件除非比本地文件新 -S, –server-response 打印服务器的回应 –spider 不下载任何东西 -T, –timeout=SECONDS 设定响应超时的秒数 -w, –wait=SECONDS 两次尝试之间间隔SECONDS秒 –waitretry=SECONDS 在重新链接之间等待1…SECONDS秒 –random-wait 在下载之间等待0…2*WAIT秒 -Y, –proxy=on/off 打开或关闭代理 -Q, –quota=NUMBER 设置下载的容量限制 –limit-rate=RATE 限定下载输率\n目录 -nd –no-directories 不创建目录 -x, –force-directories 强制创建目录 -nH, –no-host-directories 不创建主机目录 -P, –directory-prefix=PREFIX 将文件保存到目录 PREFIX/… –cut-dirs=NUMBER 忽略 NUMBER层远程目录\nHTTP 选项 –http-user=USER 设定HTTP用户名为 USER. –http-passwd=PASS 设定http密码为 PASS. -C, –cache=on/off 允许/不允许服务器端的数据缓存 (一般情况下允许). -E, –html-extension 将所有text/html文档以.html扩展名保存 –ignore-length 忽略 Content-Length'头域 –header=STRING 在headers中插入字符串 STRING –proxy-user=USER 设定代理的用户名为 USER –proxy-passwd=PASS 设定代理的密码为 PASS –referer=URL 在HTTP请求中包含 Referer: URL\u0026rsquo;头 -s, –save-headers 保存HTTP头到文件 -U, –user-agent=AGENT 设定代理的名称为 AGENT而不是 Wget/VERSION. –no-http-keep-alive 关闭 HTTP活动链接 (永远链接). –cookies=off 不使用 cookies. –load-cookies=FILE 在开始会话前从文件 FILE中加载cookie –save-cookies=FILE 在会话结束后将 cookies保存到 FILE文件中\nFTP 选项 -nr, –dont-remove-listing 不移走 `.listing\u0026rsquo;文件 -g, –glob=on/off 打开或关闭文件名的 globbing机制 –passive-ftp 使用被动传输模式 (缺省值). –active-ftp 使用主动传输模式 –retr-symlinks 在递归的时候，将链接指向文件(而不是目录)\n递归下载 -r, –recursive 递归下载－－慎用! -l, –level=NUMBER 最大递归深度 (inf 或 0 代表无穷). –delete-after 在现在完毕后局部删除文件 -k, –convert-links 转换非相对链接为相对链接 -K, –backup-converted 在转换文件X之前，将之备份为 X.orig -m, –mirror 等价于 -r -N -l inf -nr. -p, –page-requisites 下载显示HTML文件的所有图片\n递归下载中的包含和不包含(accept/reject) -A, –accept=LIST 分号分隔的被接受扩展名的列表 -R, –reject=LIST 分号分隔的不被接受的扩展名的列表 -D, –domains=LIST 分号分隔的被接受域的列表 –exclude-domains=LIST 分号分隔的不被接受的域的列表 –follow-ftp 跟踪HTML文档中的FTP链接 –follow-tags=LIST 分号分隔的被跟踪的HTML标签的列表 -G, –ignore-tags=LIST 分号分隔的被忽略的HTML标签的列表 -H, –span-hosts 当递归时转到外部主机 -L, –relative 仅仅跟踪相对链接 -I, –include-directories=LIST 允许目录的列表 -X, –exclude-directories=LIST 不被包含目录的列表 -np, –no-parent 不要追溯到父目录\n"
    },
    {
        "uri": "https://linuxsuren.github.io/opensource/why-opensource/",
        "title": "Why OpenSource",
        "tags": [],
        "description": "Why I&#39;d like OpenSource",
        "content": "为什么要参与开源事业？这是一个非常好的问题。下面，我会对此发表几个观点。\n先说，为什么会考虑参与开源。在工作了几个年头之后，我发现了一个问题——做了很多的项目，或大或小，我的角色只是个 Coding 的劳动力。 也许有人对此有别的看法，但是，对于走进 IT 行业的头三年了去我差不多就是这么理解的。学习几个框架，写段后端逻辑，改改页面上的按钮、菜单。 由于缺少经验，没有自己的想法，提不出好的建议。有些逻辑能力强的人，会感觉自己能够精通几个框架。但是，这些所谓的框架更新换代太快， 我们又不会总是那么年轻，总是有那么多的时间来无尽地学习。\n然后，某个机会，开始对开源慢慢地有些了解。其实，这是非常地有意思的一件事情。我想，从 Java 开始走向编程之路的程序员们，应该不可能 没有听说过、用过开源的项目。但是，国内这些程序员里，却只有少部分的人尝试过去参与开源。\n一开始，我也是抱着试试的态度的。当时，感觉做开源的人应该都很厉害吧，比如当时很流行的 Spring 框架。毕竟，用的都不是很熟悉，怎么可能 去参与开源开发呢。对，这就是很大的一个误区——参与开源项目，不一定只能是参与代码的编写。按照我目前的认识，代码编写，真的只是开源事业 中很小的一部分。\n上面提到了一些企业开发中的痛点，对公司的项目没有足够的参与感。我这里问读者一个问题，不管你现在有几年的工作经验：对于你们公司的项目， 你有多少的话语权呢？项目的功能模块，要做哪些、怎么做，设计与技术架构都是由哪些人来决定的呢？在很长的一段时间内，这些都是由公司的 项目经历来确定的，我只是努力在 Deadline 之前交付。但是，在好的开源社区里，完全不是这么来的。\n喊了多少年的单元测试，不再是说说而已，这是必须的，甚至比业务代码更加重要。\n我感觉项目中，应该加上一个很棒的特性。先在邮件组里发一封邮件，给出原型，大家讨论一下。如果切实可行的话，可能几周、几月内这个功能特性 就上线了。也许，我的这个提议会给很多人带来一些遍历；也许，自己小小的虚荣心会得到满足。总之，好的开源社区一定民主，而不是专制的。\n公司里的那个项目，我才做了一个月就被砍掉了。完全不知道为什么要做那个，也没有学习到任何的东西。在这里，要看你的眼光，选准一个好的社区， 你可以在这个社区里贡献五年、十年，甚至是整个事业周期。也许，你会做这个项目里的每行代码都很熟悉；当你再次说出精通时不再心虚。\n参与开源的好处。\n我在公司里干活，会有人支付我薪水。做开源，甚至都没有人来一步步地告诉我怎么做，完全蒙。更要命的是，没有任何的经济回报。\n是的，参与开源，并不会有人来支付你工资，更没有奖金。我给你一个很虚，也很实在的理由，那就是开源会让你更容易知道归属感，让你不再感觉 自己只是个廉价劳动力。像 Jenkins、Kubernetes 这样的项目，除非你自己决定不再贡献，没有人可以阻止你参与。你也能很容易地看到，有很多 人在使用你参与开发的项目，包括你自己。\n如果你喜欢技术，那么，当你参与某个项目三五年后，你会精通这个项目周边的整个技术栈。你会亲自看着这个项目的兴衰。之后，你还会发现除了 技术还有很多很重要的东西。因为，当你真正地开始关心这个项目后，你会想各种办法来确保她可以健康地发展。你会发现，当初嗤之以鼻的文档 真的太重要了。你会发现，沟通能力也是非常基础的要求。你会发现，你愿意借助各种机会来宣传你的项目。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/xargs/",
        "title": "xargs",
        "tags": [],
        "description": "xargs",
        "content": "docker images | grep nginx | awk '{print $3}' | xargs docker rmi 删除包含指定字符的 Docker 镜像\n参数 ls | xargs -I {} mv {} {}.bak 多次使用参数\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/xclip/",
        "title": "xclip",
        "tags": [],
        "description": "command line interface to X selections (clipboard)",
        "content": "Install sudo apt-get install xclip\nExample ifconfig | xclip -sel clip\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/golang/install/",
        "title": "安装",
        "tags": [],
        "description": "如何按照 Golang",
        "content": "CentOS yum install go -y\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/k8s/install/",
        "title": "安装 Kubernetes",
        "tags": [],
        "description": "在宿主机上安装 K8S",
        "content": "启用 Docker 服务 systemctl enable docker.service\n安装 go 依赖 go get github.com/kubernetes-incubator/cri-tools/cmd/crictl\n安装客户端\ncat \u0026lt;\u0026lt;EOF \u0026gt; /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64 enabled=1 gpgcheck=1 repo_gpgcheck=1 gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg EOF setenforce 0 yum install -y kubelet kubeadm kubectl systemctl enable kubelet \u0026amp;\u0026amp; systemctl start kubelet 设置 kubelet sed -i \u0026quot;s/cgroup-driver=systemd/cgroup-driver=cgroupfs/g\u0026quot; /etc/systemd/system/kubelet.service.d/10-kubeadm.conf\n重启 kubelet systemctl daemon-reload \u0026amp;\u0026amp; systemctl restart kubelet\n禁用Swap swapoff -a\n安装 master kubeadm init\nexport LC_ALL=en_US.utf-8 export LANG=en_US.utf-8\ndocker pull registry.cn-hangzhou.aliyuncs.com/surenpi/etcd-amd64:3.0.17 docker pull registry.cn-hangzhou.aliyuncs.com/surenpi/pause-amd64:3.0 docker pull registry.cn-hangzhou.aliyuncs.com/surenpi/kube-proxy-amd64:v1.7.2 docker pull registry.cn-hangzhou.aliyuncs.com/surenpi/kube-scheduler-amd64:v1.7.2 docker pull registry.cn-hangzhou.aliyuncs.com/surenpi/kube-controller-manager-amd64:v1.7.2 docker pull registry.cn-hangzhou.aliyuncs.com/surenpi/kube-apiserver-amd64:v1.7.2 docker pull registry.cn-hangzhou.aliyuncs.com/surenpi/kubernetes-dashboard-amd64:v1.6.1 docker pull registry.cn-hangzhou.aliyuncs.com/surenpi/k8s-dns-sidecar-amd64:1.14.4 docker pull registry.cn-hangzhou.aliyuncs.com/surenpi/k8s-dns-kube-dns-amd64:1.14.4 docker pull registry.cn-hangzhou.aliyuncs.com/surenpi/k8s-dns-dnsmasq-nanny-amd64:1.14.4 docker tag registry.cn-hangzhou.aliyuncs.com/surenpi/etcd-amd64:3.0.17 gcr.io/google_containers/etcd-amd64:3.0.17 docker tag registry.cn-hangzhou.aliyuncs.com/surenpi/pause-amd64:3.0 gcr.io/google_containers/pause-amd64:3.0 docker tag registry.cn-hangzhou.aliyuncs.com/surenpi/kube-proxy-amd64:v1.7.2 gcr.io/google_containers/kube-proxy-amd64:v1.7.2 docker tag registry.cn-hangzhou.aliyuncs.com/surenpi/kube-scheduler-amd64:v1.7.2 gcr.io/google_containers/kube-scheduler-amd64:v1.7.2 docker tag registry.cn-hangzhou.aliyuncs.com/surenpi/kube-controller-manager-amd64:v1.7.2 gcr.io/google_containers/kube-controller-manager-amd64:v1.7.2 docker tag registry.cn-hangzhou.aliyuncs.com/surenpi/kube-apiserver-amd64:v1.7.2 gcr.io/google_containers/kube-apiserver-amd64:v1.7.2 docker tag registry.cn-hangzhou.aliyuncs.com/surenpi/kubernetes-dashboard-amd64:v1.6.1 gcr.io/google_containers/kubernetes-dashboard-amd64:v1.6.1 docker tag registry.cn-hangzhou.aliyuncs.com/surenpi/k8s-dns-sidecar-amd64:1.14.4 gcr.io/google_containers/k8s-dns-sidecar-amd64:1.14.4 docker tag registry.cn-hangzhou.aliyuncs.com/surenpi/k8s-dns-kube-dns-amd64:1.14.4 gcr.io/google_containers/k8s-dns-kube-dns-amd64:1.14.4 docker tag registry.cn-hangzhou.aliyuncs.com/surenpi/k8s-dns-dnsmasq-nanny-amd64:1.14.4 gcr.io/google_containers/k8s-dns-dnsmasq-nanny-amd64:1.14.4 https://www.cnblogs.com/ericnie/p/7749588.html\n/etc/kubernetes/bootstrap-kubelet.conf\nkubectl get cm -n kube-public cluster-info -o yaml\nkubectl label nodes 10-19-169-138 name=master\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/language/python/install/",
        "title": "安装 Python",
        "tags": [],
        "description": "",
        "content": "yum install python\nyum install python-pip\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/packagemanager/",
        "title": "包管理器",
        "tags": [],
        "description": "",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/editor/",
        "title": "编辑器",
        "tags": [],
        "description": "编辑器",
        "content": "编辑器\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/pipeline/parameterized/",
        "title": "参数化流水线",
        "tags": [],
        "description": "参数化流水线",
        "content": "参数化可以避免创建很多相似的流水线，例如：同一个代码仓库，每次希望构建的分支不一样，就可以把分支的名称作为参数。\n类型 流水线支持很多类型的参数，包括：字符串、布尔值、密码、文件，甚至可以获取到其他任务（job）的数据。\n点击这里查看更多的参数类型\n位置 参数可以直接写在 Jenkinsfile 中，也可以在流水线配置界面上添加。下面给出一个在 Jenkinsfile 中添加参数的的例子：\ncodes/jenkinsfile/parameter.groovy pipeline { agent { label \u0026#34;master\u0026#34; } parameters { text defaultValue: \u0026#39;Rick\u0026#39;, description: \u0026#39;\u0026#39;, name: \u0026#39;name\u0026#39; } stages{ stage(\u0026#34;one\u0026#34;){ steps{ echo name sh \u0026#39;echo ${name}\u0026#39; } } } } 原文件 执行历史 每次执行时的参数值，都可以在执行历史中看到。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/network/proxy/",
        "title": "代理",
        "tags": [],
        "description": "如何配置代理",
        "content": "分类 ssh shadowsocks Ubuntu sudo apt-get install shadowsocks\nCentOS yum install shadowsocks\npip install shadowsocks\nsudo pip install shadowsocks --upgrade\n使用 sudo sslocal -c shadowsocks.json -d start\npolipo 安装 sudo apt-get install polipo\nbrew install polip\n安装依赖 yum install texinfo -y 然后下载源码 git clone https://github.com/jech/polipo.git 最后编译 cd polipo \u0026amp;\u0026amp; make all \u0026amp;\u0026amp; make install\n使用 polipo socksParentProxy=127.0.0.1:1080\n配置终端的代理 HTTP_PROXY=http://127.0.0.1:8123 HTTPS_PROXY=http://127.0.0.1:8123 SOCKS_PROXY=socks5://127.0.0.1:1080 no_proxy=*.baidu.com,localhost,127.0.0.1,192.18.*.*, export HTTP_PROXY HTTPS_PROXY no_proxy 参考 如何给 Git 配置代理\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/codequality/",
        "title": "代码质量",
        "tags": [],
        "description": "代码质量相关内容",
        "content": "代码质量相关内容\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/build/maven-release/",
        "title": "发布Maven工程到中央仓库",
        "tags": [],
        "description": "本文介绍如何把自己的maven项目发布到OSS中央仓库中",
        "content": "注册帐号 https://issues.sonatype.org/secure/Signup!default.jspa\n新建项目 https://issues.sonatype.org/secure/CreateIssue.jspa?issuetype=21\u0026amp;pid=10134\nsonatype对发布的jar有一些要求，必须包括：源码（既然是开源，那么源码肯定是少不了的）、javaDoc、gpg签名。下面介绍如何安装gpg工具，然后生成签名文件。\n签名 参考这里安装gpg。完成后，按照下面的步骤生成密钥。\ngpg --gen-key 生成密钥，成功后，会有类似如下的输出。\ngpg: key 69EC4448C6CE32EB marked as ultimately trusted\ngpg: directory \u0026lsquo;/Users/mac/.gnupg/openpgp-revocs.d\u0026rsquo; created\n69EC4448C6CE32EB就是我们需要的keyname，会在maven的settings.xml中配置。\n修改settings.xml 增加账户信息：\n\u0026lt;server\u0026gt; \u0026lt;id\u0026gt;hello\u0026lt;/id\u0026gt; \u0026lt;username\u0026gt;name\u0026lt;/username\u0026gt; \u0026lt;password\u0026gt;passwd\u0026lt;/password\u0026gt; \u0026lt;/server\u0026gt; 设置gpg的profile：\n\u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;hello\u0026lt;/id\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;activeByDefault\u0026gt;true\u0026lt;/activeByDefault\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;gpg.executable\u0026gt;gpg2\u0026lt;/gpg.executable\u0026gt; \u0026lt;gpg.passphrase\u0026gt;pass\u0026lt;/gpg.passphrase\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; 需要注意的是，gpg有两个版本gpg和gpg2。maven的gpg插件，默认使用gpg命令来作签名，如果你需要使用gpg2的话，可以在参考上面的配置来修改（gpg.executable）。另外，上面的配置中，直接写了密钥，这样可能是不安全的。你可以在配置文件中配置keyname，如下所示：\n\u0026lt;gpg.keyname\u0026gt;69EC4448C6CE32EB\u0026lt;/gpg.keyname\u0026gt;\n\u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;gpg\u0026lt;/id\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;gpg.keyname\u0026gt;4FD28481A917951C\u0026lt;/gpg.keyname\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; 修改pom文件 \u0026lt;distributionManagement\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;oss-sonatype-staging\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Sonatype Staging Repository\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://oss.sonatype.org/service/local/staging/deploy/maven2\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;snapshotRepository\u0026gt; \u0026lt;id\u0026gt;oss-sonatype-staging\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;OSS Sonatype Nexus Snapshots\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://oss.sonatype.org/content/repositories/snapshots\u0026lt;/url\u0026gt; \u0026lt;/snapshotRepository\u0026gt; \u0026lt;/distributionManagement\u0026gt; 上面的配置，描述了版本（release、snapshot）的发布地址。另外，这里的id需要和settings.xml中server的id保持一致。然后，添加生成javaDoc、源码等的Maven插件：\n\u0026lt;profiles\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;release\u0026lt;/id\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-gpg-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;sign-artifacts\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;verify\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;sign\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-enforcer-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.1\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;enforce-no-snapshots\u0026lt;/id\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;enforce\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;rules\u0026gt; \u0026lt;requireReleaseDeps\u0026gt; \u0026lt;message\u0026gt;No Snapshots Allowed!\u0026lt;/message\u0026gt; \u0026lt;/requireReleaseDeps\u0026gt; \u0026lt;/rules\u0026gt; \u0026lt;fail\u0026gt;true\u0026lt;/fail\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-javadoc-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.10.3\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;additionalparam\u0026gt;${javadoc.opts}\u0026lt;/additionalparam\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;attach-javadocs\u0026lt;/id\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;jar\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-source-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.4\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;attach-sources\u0026lt;/id\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;jar\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;doclint-java8-disable\u0026lt;/id\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;jdk\u0026gt;[1.8,)\u0026lt;/jdk\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;javadoc.opts\u0026gt;-Xdoclint:none\u0026lt;/javadoc.opts\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/profiles\u0026gt; 发布 经过上面繁琐的配置后，现在终于可以发布项目到Maven公共仓库了。\n在项目根目录下（根据需要自行选择），执行命令mvn deploy\n如果没有任何报错的话，会先把jar等文件上传（upload）。等上传完成后，你需要登录https://oss.sonatype.org ，点击左侧菜单Staging Repositories。从列表中找到你刚刚上传的工程，选中后点击Close。如果你不想每次手动完成该步骤，可以在pom.xml中添加下面的插件配置来实现自动化：\n\u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.sonatype.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;nexus-staging-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.6.7\u0026lt;/version\u0026gt; \u0026lt;extensions\u0026gt;true\u0026lt;/extensions\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;serverId\u0026gt;nexus-snapshots\u0026lt;/serverId\u0026gt; \u0026lt;nexusUrl\u0026gt;https://oss.sonatype.org/\u0026lt;/nexusUrl\u0026gt; \u0026lt;autoReleaseAfterClose\u0026gt;true\u0026lt;/autoReleaseAfterClose\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; 多模块 有些Maven工程是多模块工程，这时候，如果我们希望把特定的模块在deploy的时候排除掉，可以通过下面的配置来实现：\n\u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-deploy-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.8.2\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;skip\u0026gt;true\u0026lt;/skip\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; 你可以把上面的配置添加到需要排除的模块中。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/pipeline/scripted/",
        "title": "脚本式流水线",
        "tags": ["Jenkins", "Pipeline"],
        "description": "本文介绍 Jenkins 的脚本式流水线",
        "content": "触发器 codes/jenkinsfile/script-trigger.groovy node(\u0026#39;local\u0026#39;) { echo \u0026#39;hello\u0026#39; } properties([ buildDiscarder( logRotator( artifactDaysToKeepStr: \u0026#39;\u0026#39;, artifactNumToKeepStr: \u0026#39;\u0026#39;, daysToKeepStr: \u0026#39;5\u0026#39;, numToKeepStr: \u0026#39;10\u0026#39; ) ), pipelineTriggers([ cron(\u0026#39;H 3,12,17 * * *\u0026#39;), scm(\u0026#39;H 3,12,17 * * *\u0026#39;) ]) ]) 原文件 参数化执行 properties([[$class: \u0026#39;JobRestrictionProperty\u0026#39;], parameters([run(description: \u0026#39;\u0026#39;, filter: \u0026#39;ALL\u0026#39;, name: \u0026#39;Name\u0026#39;, projectName: \u0026#39;Project\u0026#39;)]), pipelineTriggers([])] ) 异常 你可以利用处理异常的方式来实现类似于申明式流水线中的 post\ncodes/jenkinsfile/try-catch.groovy node { stage(\u0026#34;one\u0026#34;){ try { echo \u0026#34;hello\u0026#34; }catch(error){ echo error.getMessage() }finally{ echo \u0026#34;finally\u0026#34; } } } 原文件 循环 codes/jenkinsfile/loop.groovy node(\u0026#39;suren\u0026#39;) { def dev_path = \u0026#39;/opt/suren/bin\u0026#39; def services = [ [ \u0026#39;name\u0026#39;: \u0026#39;admin\u0026#39;, \u0026#39;project\u0026#39;: \u0026#39;admin\u0026#39;, \u0026#39;port\u0026#39;: \u0026#39;7002\u0026#39;, \u0026#39;jarName\u0026#39;: \u0026#39;admin\u0026#39; ] ]; stage(\u0026#39;Copy Artifact\u0026#39;) { for(service in services){ step([$class: \u0026#39;CopyArtifact\u0026#39;, fingerprintArtifacts: true, flatten: true, projectName: service.project, selector: [$class: \u0026#39;StatusBuildSelector\u0026#39;, stable: false], target: dev_path \u0026#43; \u0026#39;/\u0026#39; \u0026#43; service.name ]) } } stage(\u0026#39;Stop Service\u0026#39;) { for(service in services){ sh \u0026#39;fuser -n tcp -k \u0026#39; \u0026#43; service.port \u0026#43; \u0026#39; \u0026gt; redirection \u0026amp;\u0026#39; } } stage(\u0026#39;Start Service\u0026#39;) { for(service in services){ sh \u0026#39;cd \u0026#39; \u0026#43; pass_bin \u0026#43; \u0026#39;/\u0026#39; \u0026#43; service.name \u0026#43; \u0026#39; \u0026amp;\u0026amp; nohup nice java -server -Xms128m -Xmx384m \\ -jar \u0026#39; \u0026#43; service.jarName \u0026#43; \u0026#39;.jar \\ --server.port=\u0026#39; \u0026#43; service.port \u0026#43; \u0026#39; $\u0026gt; initServer.log 2\u0026gt;\u0026amp;1 \u0026amp;\u0026#39; } } } 原文件 HTTP 我们有时候需要在流水线中发送 HTTP 请求，下面给出一个例子：\ncodes/jenkinsfile/http.groovy // dependecy plugin is https://plugins.jenkins.io/phoenix-autotest pipeline { agent { label \u0026#34;master\u0026#34; } stages { stage(\u0026#39;test\u0026#39;) { steps{ script { http url: \u0026#34;http://baidu.com\u0026#34; http url: \u0026#34;http://baidu.com\u0026#34;, responseBody: \u0026#34;body.txt\u0026#34; archiveArtifacts \u0026#34;body.txt\u0026#34; def quy = \u0026#39;https://www.baidu.com/s?wd=\u0026#39; \u0026#43; URLEncoder.encode(\u0026#39;a b\u0026#39;, \u0026#39;UTF-8\u0026#39;) echo quy http url: quy } } } } } 原文件 "
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/browser/",
        "title": "浏览器",
        "tags": [],
        "description": "浏览器",
        "content": "浏览器\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/prompting/",
        "title": "命令提示符",
        "tags": [],
        "description": "命令提示符",
        "content": "命令提示符 使用命令 echo $PS1 可以查看当前的命令提示符配置\nexport PS1='[/u@/h /W/]/$ '\n\\u 当前用户帐号\n\\h 当前主机名\n\\W 当前路径（大写为相对路径，小写为绝对路径）\n\\$\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/docker/docker-config/",
        "title": "配置",
        "tags": [],
        "description": "配置",
        "content": "代理 给 Docker 设置代理，该代理是在拉取镜像时的网络代理设置\nmkdir -p /etc/systemd/system/docker.service.d cat \u0026gt; /etc/systemd/system/docker.service.d/http-proxy.conf \u0026lt;\u0026lt; EOF [Service] Environment=\u0026#34;HTTP_PROXY=http://your.proxy:8080\u0026#34; Environment=\u0026#34;HTTPS_PROXY=http://your.proxy:8080\u0026#34; Environment=\u0026#34;NO_PROXY=127.0.0.1,localhost\u0026#34; EOF systemctl daemon-reload systemctl restart docker 运行时代理 { \u0026#34;HttpHeaders\u0026#34;: { \u0026#34;User-Agent\u0026#34;: \u0026#34;Docker-Client/19.03.4 (linux)\u0026#34; }, \u0026#34;proxies\u0026#34;: { \u0026#34;default\u0026#34;: { \u0026#34;httpProxy\u0026#34;: \u0026#34;http://172.17.212.62:3128\u0026#34;, \u0026#34;httpsProxy\u0026#34;: \u0026#34;http://172.17.212.62:3128\u0026#34;, \u0026#34;noProxy\u0026#34;: \u0026#34;127.0.0.1,localhost,172.17.212.63\u0026#34; } } } Insecure vim /etc/systemd/system/docker.service.d/docker.conf\n[Service] ExecStart= ExecStart=/usr/bin/dockerd -H fd:// --insecure-registry 10.101.101.45:5000 vim /etc/docker/daemon.json\n\u0026quot;insecure-registries\u0026quot; : [\u0026quot;192.168.0.180\u0026quot;]\nUbuntu 下修改配置文件 vim /etc/default/docker 添加如下内容：\nDOCKER_OPTS=\u0026quot;$DOCKER_OPTS --insecure-registry registry_server_name/ip:port\u0026quot;\nUser 让普通用户可以执行 docker\nsudo groupadd docker\nsudo gpasswd -a ${USER} docker\nsudo service docker restart\n并发下载（推送）镜像 下面的示例中给出了如何设置（/etc/docker/daemon.json）并发下载或者推送镜像层的配置：\n{ \u0026#34;max-concurrent-uploads\u0026#34;: 20, \u0026#34;max-concurrent-downloads\u0026#34;: 20, \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://qtzsrp4m.mirror.aliyuncs.com\u0026#34;, \u0026#34;https://hub-mirror.c.163.com\u0026#34;, \u0026#34;https://mirror.baidubce.com\u0026#34; ] } 重启服务 执行命令 systemctl daemon-reload \u0026amp;\u0026amp; systemctl stop docker \u0026amp;\u0026amp; systemctl start docker\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/configuration/",
        "title": "配置文件",
        "tags": [],
        "description": "介绍各种配置文件",
        "content": "介绍有关配置的问题\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/os/linux/common/determine-version/",
        "title": "确定 Linux 发行版的版本信息",
        "tags": [],
        "description": "确定 Linux 发行版的版本信息",
        "content": "Ubuntu lsb_release -a\ncat /etc/redhat-release\ncat /proc/version\ncat /etc/issue\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/jenkins/pipeline/declarative/",
        "title": "申明式流水线",
        "tags": ["Jenkins"],
        "description": "申明式流水线",
        "content": "流水线插件从 2.5 版本开始支持申明式流水线。\n申明式流水线（Declarative Pipeline）的语法结构更加清晰，而且兼容脚本式流水线。下面给出一个例子：\ncodes/jenkinsfile/declarative.groovy pipeline { agent { label \u0026#39;master\u0026#39; } stages { stage(\u0026#39;one\u0026#39;) { when { branch \u0026#39;master\u0026#39; } steps { echo \u0026#39;Hello World\u0026#39; } } } post { always { echo \u0026#39;I will always say Hello again!\u0026#39; } } } 原文件 如果您对 Jenkins 的流水线功能感兴趣，可以点击这里查看对应的插件介绍。\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/database/",
        "title": "数据库",
        "tags": [],
        "description": "数据库",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/network/",
        "title": "网络",
        "tags": [],
        "description": "",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/document/",
        "title": "文档技术",
        "tags": [],
        "description": "文档技术",
        "content": "文档技术\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/server/",
        "title": "应用服务",
        "tags": [],
        "description": "有关应用服务的配置",
        "content": ""
    },
    {
        "uri": "https://linuxsuren.github.io/blog/devops/docker/docker-centos/",
        "title": "在 CentOS 安装 Docker",
        "tags": [],
        "description": "在 CentOS 安装 Docker",
        "content": "yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine 安装依赖：\nyum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 添加库\nyum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 查看版本 yum list docker-ce --showduplicates | sort -r\n安装 Docker yum install docker-ce 安装执行版本 yum install docker-ce17.12.0.ce-1.el7.centos\n"
    },
    {
        "uri": "https://linuxsuren.github.io/blog/other/terminal/",
        "title": "终端",
        "tags": [],
        "description": "终端",
        "content": ""
    }]